<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SQL优化技巧</title>
    <link href="/2022/08/10/SQL%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/08/10/SQL%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在数据库的应用过程中，需要针对查询等进行一些优化，记录以下一些常用的优化策略。</p><h1 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h1><p>对于MySQL层优化一般遵从以下原则：</p><ul><li>减少数据访问：设置合理的字段类型，启用压缩，通过索引访问等减少磁盘IO。</li><li>返回更少的数据：只返回需要的字段和数据分页处理，减少磁盘 IO 及网络 IO。</li><li>减少交互次数：批量DML操作，函数存储等减少数据连接次数。</li><li>减少服务器CPU开销：尽量减少数据库排序操作以及全表查询，减少CPU内存占用。</li><li>利用更多资源：使用表分区，可以增加并行操作，更大限度利用CPU资源。</li></ul><p>总结到SQL优化中，就是如下几点：</p><ul><li>最大化利用索引；</li><li>尽可能避免全表扫描；</li><li>减少无效数据的查询。</li></ul><h1 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h1><p>要理解SQL优化原理，首先需要搞清楚SQL执行顺序。</p><p>其中，SELECT语句语法顺序如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  <br><span class="hljs-keyword">DISTINCT</span> <span class="hljs-operator">&lt;</span>select_list<span class="hljs-operator">&gt;</span> <br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>left_table<span class="hljs-operator">&gt;</span> <br><span class="hljs-operator">&lt;</span>join_type<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-operator">&lt;</span>right_table<span class="hljs-operator">&gt;</span> <br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>join_condition<span class="hljs-operator">&gt;</span> <br><span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>where_condition<span class="hljs-operator">&gt;</span> <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>group_by_list<span class="hljs-operator">&gt;</span> <br><span class="hljs-keyword">HAVING</span> <span class="hljs-operator">&lt;</span>having_condition<span class="hljs-operator">&gt;</span> <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>order_by_condition<span class="hljs-operator">&gt;</span> <br>LIMIT <span class="hljs-operator">&lt;</span>limit_number<span class="hljs-operator">&gt;</span> <br></code></pre></td></tr></table></figure><p>执行顺序如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">FROM</span> <br><span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> # 选取表，将多个表数据通过笛卡尔积变成一个表。 <br><span class="hljs-keyword">ON</span> <br><span class="hljs-operator">&lt;</span>筛选条件<span class="hljs-operator">&gt;</span> # 对笛卡尔积的虚表进行筛选 <br><span class="hljs-keyword">JOIN</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">join</span>, <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span>, <span class="hljs-keyword">right</span> join...<span class="hljs-operator">&gt;</span>  <br><span class="hljs-operator">&lt;</span><span class="hljs-keyword">join</span>表<span class="hljs-operator">&gt;</span> # 指定<span class="hljs-keyword">join</span>，用于添加数据到<span class="hljs-keyword">on</span>之后的虚表中，例如<span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span>会将左表的剩余数据添加到虚表中 <br><span class="hljs-keyword">WHERE</span> <br><span class="hljs-operator">&lt;</span><span class="hljs-keyword">where</span>条件<span class="hljs-operator">&gt;</span> # 对上述虚表进行筛选 <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <br><span class="hljs-operator">&lt;</span>分组条件<span class="hljs-operator">&gt;</span> # 分组 <br><span class="hljs-operator">&lt;</span><span class="hljs-built_in">SUM</span>()等聚合函数<span class="hljs-operator">&gt;</span> # 用于<span class="hljs-keyword">having</span>子句进行判断，在书写上这类聚合函数是写在<span class="hljs-keyword">having</span>判断里面的 <br><span class="hljs-keyword">HAVING</span> <br><span class="hljs-operator">&lt;</span>分组筛选<span class="hljs-operator">&gt;</span> # 对分组后的结果进行聚合筛选 <br><span class="hljs-keyword">SELECT</span> <br><span class="hljs-operator">&lt;</span>返回数据列表<span class="hljs-operator">&gt;</span> # 返回的单列必须在<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>子句中，聚合函数除外 <br><span class="hljs-keyword">DISTINCT</span> <br># 数据除重 <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <br><span class="hljs-operator">&lt;</span>排序条件<span class="hljs-operator">&gt;</span> # 排序 <br>LIMIT <br><span class="hljs-operator">&lt;</span>行数限制<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h1 id="SQL优化策略"><a href="#SQL优化策略" class="headerlink" title="SQL优化策略"></a>SQL优化策略</h1><h2 id="避免不走索引的场景"><a href="#避免不走索引的场景" class="headerlink" title="避免不走索引的场景"></a>避免不走索引的场景</h2><p>（1）<strong>尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描</strong></p><p>如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> username <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%王%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>优化方式：尽量在字段后面使用模糊查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> username <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;王%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>如果需求是要在前面使用模糊查询：</p><ul><li>使用 MySQL 内置函数 INSTR(str，substr)来匹配，作用类似于 Java 中的 indexOf()，查询字符串出现的角标位置。</li><li>使用 FullText 全文索引，用 match against 检索。</li><li>数据量较大的情况，建议引用 ElasticSearch、Solr，亿级数据量检索速度秒级。</li></ul><p>（2）<strong>尽量避免使用 in 和 not in，会导致引擎走全表扫描</strong></p><p>如果是子查询，可以用 exists 代替。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 不走索引 </span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> A.id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> B); <br><span class="hljs-comment">-- 走索引 </span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> B.id <span class="hljs-operator">=</span> A.id); <br></code></pre></td></tr></table></figure><p>（3）<strong>尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 优化前</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">OR</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br><br><span class="hljs-comment">-- 优化：可以用union代替or</span><br><span class="hljs-comment">-- 优化后</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>   <span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>（4）<strong>尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> score <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br><br><span class="hljs-comment">-- 优化：可以给字段添加默认值0，对0值进行判断</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> socre <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>（5）<strong>尽量避免在 where 条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描</strong></p><p><strong>优化建议</strong>：可以将表达式、函数操作移动到等号右侧。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 全表扫描 </span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> T <span class="hljs-keyword">WHERE</span> score<span class="hljs-operator">/</span><span class="hljs-number">10</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span> <br><br><span class="hljs-comment">-- 走索引 </span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> T <span class="hljs-keyword">WHERE</span> score <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-operator">*</span><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>（6）<strong>当数据量大时，避免使用 where 1=1 的条件</strong></p><p>通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。</p><p>优化方式：用代码拼装SQL时进行判断，没where条件就去掉where，有where条件就加and。</p><p>（7）<strong>order by 条件要与 where 中条件一致，否则 order by 不会利用索引进行排序</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 不走age索引 </span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age; <br> <br><span class="hljs-comment">-- 走age索引 </span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age;<br></code></pre></td></tr></table></figure><h2 id="SELECT语句其它优化"><a href="#SELECT语句其它优化" class="headerlink" title="SELECT语句其它优化"></a>SELECT语句其它优化</h2><p>（1）**避免出现SELECT ***</p><p>（2）<strong>多表关联查询时，小表在前，大表在后</strong></p><p>（3）<strong>使用表的别名</strong></p><p>当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减少那些有列名歧义引起的语法错误。</p><p>（4）<strong>用WHERE子句替换HAVING子句</strong></p><p>避免使用 HAVING 字句，因为 HAVING 只会在检索出所有记录之后才对结果集进行过滤，而 where 则是在聚合前刷选记录，如果能通过 where 字句限制记录的数目，那就能减少这方面的开销。</p><p>HAVING 中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在 where 字句中。</p><p>where 和 having 的区别：where 后面不能使用组函数。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>SQL优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
      <tag>SQL优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题库</title>
    <link href="/2022/08/02/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/"/>
    <url>/2022/08/02/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="为什么要对网络协议进行分层"><a href="#为什么要对网络协议进行分层" class="headerlink" title="为什么要对网络协议进行分层"></a>为什么要对网络协议进行分层</h2><ul><li><p>易于实现和维护，因为各层之间是独立的，层与层之间不会受到影响</p></li><li><p>有利于标准化的制定</p><h2 id="计算机网络的各层协议及作用"><a href="#计算机网络的各层协议及作用" class="headerlink" title="计算机网络的各层协议及作用"></a>计算机网络的各层协议及作用</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658494699266-3d3fc9cb-5fc4-4bff-af85-f4217cfa4152.png#clientId=uf0be6986-5431-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=786&id=u94b21744&margin=%5Bobject%20Object%5D&name=image.png&originHeight=786&originWidth=835&originalType=binary&ratio=1&rotation=0&showTitle=false&size=84362&status=done&style=none&taskId=u66cebb8a-3fe3-488d-be1c-f8fb280fa04&title=&width=835" alt="image.png"></p></li><li><p>应用层</p></li></ul><p>应用层的任务是通过应用进程之间的交互来完成特定的网络作用，常见的应用层协议有域名系统DNS, HTTP协议等。</p><ul><li>表示层</li></ul><p>表示层的主要作用是数据的表示、安全、压缩。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</p><ul><li>会话层</li></ul><p>会话层的主要作用是建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。</p><ul><li>传输层</li></ul><p>传输层的主要作用是负责向两台主机进程之间的通信提供数据传输服务。传输层的协议主要有传输控制协议TCP和用户数据协议UDP。</p><ul><li>网络层</li></ul><p>网络层的主要作用是选择合适的网间路由和交换结点，确保数据及时送达。常见的协议有IP协议。</p><ul><li>数据链路层</li></ul><p>数据链路层的作用是在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧(Frame) 在信道上无差错的传输，并进行各电路上的动作系列。常见的协议有SDLC、HDLC、PPP等。</p><ul><li>物理层</li></ul><p>物理层的主要作用是实现相邻计算机结点之间比特流的透明传输，并尽量屏蔽掉具体传输质和物理设备的差异。</p><h2 id="TCP与UDP有什么区别"><a href="#TCP与UDP有什么区别" class="headerlink" title="TCP与UDP有什么区别"></a>TCP与UDP有什么区别</h2><table><thead><tr><th></th><th><strong>是否面向连接</strong></th><th><strong>可靠性</strong></th><th><strong>传输模式</strong></th><th><strong>传输效率</strong></th><th><strong>消耗资源</strong></th><th><strong>应用场景</strong></th><th><strong>首部字节</strong></th></tr></thead><tbody><tr><td><strong>TCP</strong></td><td>是</td><td>可靠</td><td>字节流</td><td>慢</td><td>多</td><td>文件/邮件传输</td><td>20-60</td></tr><tr><td><strong>UDP</strong></td><td>否</td><td>不可靠</td><td>数据报文段</td><td>快</td><td>少</td><td>视频/语音传输</td><td>8</td></tr></tbody></table><h3 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h3><p>前20个字节是固定的，后面有4n个字节是根据需而增加的选项，所以TCP首部最小长度为20字节。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658912312264-b1956113-faa9-43dc-928f-fd4bcf3902fe.png#clientId=u59fe761c-a5e8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=738&id=uc732643e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=738&originWidth=1090&originalType=binary&ratio=1&rotation=0&showTitle=false&size=619131&status=done&style=none&taskId=u45e22781-b8a2-4707-adbc-d81855b54e0&title=&width=1090" alt="image.png"></p><h3 id="UDP首部"><a href="#UDP首部" class="headerlink" title="UDP首部"></a>UDP首部</h3><p>UDP的首部只有8个字节，源端口号、目的端口号、长度和校验和各两个字节。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658912491180-733c42d7-79c6-4d39-8d38-0ceeffaa4a3d.png#clientId=u59fe761c-a5e8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=482&id=u8f31f05e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=482&originWidth=904&originalType=binary&ratio=1&rotation=0&showTitle=false&size=320817&status=done&style=none&taskId=u76d8c39c-a4f9-4f62-be8f-11aaf10374a&title=&width=904" alt="image.png"></p><h2 id="TCP协议是如何保证可靠传输"><a href="#TCP协议是如何保证可靠传输" class="headerlink" title="TCP协议是如何保证可靠传输"></a>TCP协议是如何保证可靠传输</h2><blockquote><p>主要有校验和、序列号、超时重传、流量控制及拥塞避免等几种方法。</p></blockquote><h2 id="TCP的三次握手及四次挥手"><a href="#TCP的三次握手及四次挥手" class="headerlink" title="TCP的三次握手及四次挥手"></a>TCP的三次握手及四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658546491194-41a5d5f2-8d33-4a18-a1e1-21eeb05c0de1.png#clientId=ua6c321be-9ac9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=588&id=u9662ea21&margin=%5Bobject%20Object%5D&name=image.png&originHeight=588&originWidth=901&originalType=binary&ratio=1&rotation=0&showTitle=false&size=102153&status=done&style=none&taskId=uacf313c3-85ac-48e0-8946-2b8402d80c2&title=&width=901" alt="image.png"></p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658566143708-10ee464d-303e-4694-8c90-8420d258169e.png#clientId=ua6c321be-9ac9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=637&id=u2fae9d90&margin=%5Bobject%20Object%5D&name=image.png&originHeight=637&originWidth=905&originalType=binary&ratio=1&rotation=0&showTitle=false&size=353527&status=done&style=none&taskId=u50c1dfaf-b406-46a9-b331-f4e0fe83a68&title=&width=905" alt="image.png"></p><h3 id="为什么TCP连接的时候是三次"><a href="#为什么TCP连接的时候是三次" class="headerlink" title="为什么TCP连接的时候是三次"></a>为什么TCP连接的时候是三次</h3><p>可以确保建立有效的连接，确保双方都确认连接的有效性。</p><h3 id="为什么TCP连接的时候是三次，关闭的时候缺失四次"><a href="#为什么TCP连接的时候是三次，关闭的时候缺失四次" class="headerlink" title="为什么TCP连接的时候是三次，关闭的时候缺失四次"></a>为什么TCP连接的时候是三次，关闭的时候缺失四次</h3><p>TCP通信是全双工的，需要确保通信双方都能通知对方释放连接。</p><h3 id="TIME-WAIT和CLOSE-WAIT的区别"><a href="#TIME-WAIT和CLOSE-WAIT的区别" class="headerlink" title="TIME_WAIT和CLOSE_WAIT的区别"></a>TIME_WAIT和CLOSE_WAIT的区别</h3><p>TIME_WAIT是主动发起关闭一方发送释放连接请求后在第四次挥手完成后进入的状态；CLOSE_WAIT是被动关闭一方在其返回给主动关闭一方ACK报文后进入的状态。</p><h3 id="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接"><a href="#为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接" class="headerlink" title="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接"></a>为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接</h3><p>基于客户端：<strong>清场</strong>的作用，即使本次TCP连接中的所有报文全部消失，不会出现在下一个TCP连接中。<br>基于服务端：<strong>考虑丢包</strong>，如果第四次挥手报文丢失，服务端会在等待一定时间后重新发送第三次挥手报文，如果客户端直接关闭，则收不到该重新发送的报文，致使服务端无法正常关闭。</p><h2 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h2><table><thead><tr><th></th><th><strong>HTTP</strong></th><th><strong>HTTPS</strong></th></tr></thead><tbody><tr><td><strong>端口</strong></td><td>80</td><td>443</td></tr><tr><td><strong>安全性</strong></td><td>无加密，安全性较差</td><td>有加密机制，安全性较高</td></tr><tr><td><strong>资源消耗</strong></td><td>较少</td><td>由于加密处理，资源消耗较高</td></tr><tr><td><strong>是否需要证书</strong></td><td>不需要</td><td>需要</td></tr><tr><td><strong>协议</strong></td><td>运行在TCP协议之上</td><td>运行在SSL协议之上，SSL运行在TCP协议之上</td></tr></tbody></table><h2 id="常用HTTP状态码"><a href="#常用HTTP状态码" class="headerlink" title="常用HTTP状态码"></a>常用HTTP状态码</h2><table><thead><tr><th><strong>状态码</strong></th><th><strong>类别</strong></th></tr></thead><tbody><tr><td>1XX</td><td>信息性状态码</td></tr><tr><td>2XX</td><td>成功状态码</td></tr><tr><td>3XX</td><td>重定向状态码</td></tr><tr><td>4XX</td><td>客户端错误状态码</td></tr><tr><td>5XX</td><td>服务端错误状态码</td></tr></tbody></table><h2 id="在浏览器中输入URL到显示主页发生了什么"><a href="#在浏览器中输入URL到显示主页发生了什么" class="headerlink" title="在浏览器中输入URL到显示主页发生了什么"></a>在浏览器中输入URL到显示主页发生了什么</h2><ul><li>DNS域名服务器解析输入的域名，找到对应的IP地址</li><li>和目的服务器建立TCP连接</li><li>向目的服务器发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析并渲染页面</li></ul><hr><h1 id="Java核心知识"><a href="#Java核心知识" class="headerlink" title="Java核心知识"></a>Java核心知识</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>（1）类别</strong></p><ul><li>静态变量</li><li>静态方法</li><li>静态代码块<ul><li>用于优化程序的性能，因其中的内容只会在类加载时被加载一次</li><li>一般将只需要进行一次初始化的操作放入其中</li></ul></li></ul><p><strong>（2）技巧</strong></p><ul><li>判断对象的访问范围时考虑创建时机即可</li></ul><p><strong>（3）有关的初始化顺序</strong></p><ul><li>总原则是静态变量和静态语句块优先于实例变量和普通语句块</li><li>静态变量和静态语句块的初始化顺序取决于代码中的顺序</li><li>存在继承关系，则：<ul><li>父类中的静态变量和静态语句块</li><li>子类中的静态变量和静态语句块</li><li>父类中的实例变量和普通语句块</li><li>父类的构造函数</li><li>子类的实例变量和普通语句块</li><li>子类的构造函数</li></ul></li></ul><p><strong>（4）目标</strong><br>static关键字一般用于修饰<strong>变量</strong>和<strong>方法</strong>；特殊用法是可以用于且只能用于修饰<strong>内部类</strong>；被static修饰的内部类可以直接作为一个普通类来使用，而不需要先实例一个外部类。</p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final关键字可以用于修饰类、变量和方法；</p><ul><li><p>被final修饰的类不可以<strong>被继承</strong></p></li><li><p>被final修饰的方法不可以<strong>被重写</strong></p></li><li><p>被final修饰的变量</p><ul><li>基本类型变量：变量的数值不能改变</li><li>引用类型变量：变量不能再引用其它对象，但被引用的对象是可以改变的<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3></li></ul></li><li><p>可用来引用当前类的实例变量（主要用于形参与成员名字重名）</p></li><li><p>可用于调用当前类方法（可省略）</p></li><li><p>可用来调用当前类的构造函数（this要调用的构造函数一定放在第一行）</p><h2 id="Java中子类能否重写父类的类方法-静态方法"><a href="#Java中子类能否重写父类的类方法-静态方法" class="headerlink" title="Java中子类能否重写父类的类方法/静态方法"></a>Java中子类能否重写父类的类方法/静态方法</h2></li></ul><p><strong>不能</strong>。<br>静态的方法和变量都是属于类的，在该类的字节码文件被加载到内存就分配了相应的内存空间。所以说，即便子类中有一个和父类的类方法长得一摸一样的类方法（方法体可能不同），也不能算重写，因为两者占据不同的内存空间，这个子类的静态方法是子类自己的，与父类没有关系。</p><ul><li><p>子类可以继承父类的静态方法，但不能重写它；</p></li><li><p>当子类或子类对象调用该静态方法时，调用的子类的静态方法；</p></li><li><p>当子类的上转型对象调用该静态方法时，调用的是子类继承的静态方法（即父类的）。</p><h2 id="面向对象五大基本原则"><a href="#面向对象五大基本原则" class="headerlink" title="面向对象五大基本原则"></a>面向对象五大基本原则</h2><h3 id="单一职责原则（Single-Responsibility-Principle）"><a href="#单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="单一职责原则（Single-Responsibility Principle）"></a>单一职责原则（Single-Responsibility Principle）</h3></li><li><p>一个类最好只做一件事，只有一个引起它的变化</p></li><li><p>单一引起其变化的原因则是职责</p></li><li><p>提升高内聚、低耦合水平</p><h3 id="开放封闭原则（Open-Closed-Principle）"><a href="#开放封闭原则（Open-Closed-Principle）" class="headerlink" title="开放封闭原则（Open-Closed Principle）"></a>开放封闭原则（Open-Closed Principle）</h3></li><li><p>软件实体应该是可扩展的，而不可修改的</p></li><li><p>对扩展开放，对修改关闭</p><h3 id="里氏替换原则（Liskov-Substitution-Principle）"><a href="#里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏替换原则（Liskov Substitution Principle）"></a>里氏替换原则（Liskov Substitution Principle）</h3></li><li><p>子类必须能够替换其基类</p><h3 id="依赖倒置原则（Dependency-Inversion-Principle）"><a href="#依赖倒置原则（Dependency-Inversion-Principle）" class="headerlink" title="依赖倒置原则（Dependency-Inversion Principle）"></a>依赖倒置原则（Dependency-Inversion Principle）</h3></li><li><p>依赖于抽象</p></li><li><p>高层模块不依赖于底层模块，二者都依赖于抽象</p></li><li><p>抽象不依赖于具体，具体依赖于抽象</p><h3 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface-Segregation Principle）"></a>接口隔离原则（Interface-Segregation Principle）</h3></li><li><p>使用多个小的专门的接口，而不使用一个大的总接口</p><h2 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="headerlink" title="抽象类和接口的对比"></a>抽象类和接口的对比</h2><p><code>abstract class</code>和<code>interface</code>是Java语言中支持抽象类定义的两种机制。</p></li><li><p>抽象类：用来捕捉子类的通用特性</p></li><li><p>接口：抽象方法的集合</p></li></ul><p><strong>相同点：</strong></p><ul><li>两者都不能实例化</li><li>都包含抽象方法，子类必须覆写这些方法</li></ul><p><strong>不同点：</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>抽象类</strong></th><th><strong>接口</strong></th></tr></thead><tbody><tr><td>访问修饰符</td><td>抽象方法可以有public、protected和default修饰符</td><td>接口方法默认修饰符是public，不可改变</td></tr><tr><td>构造器</td><td>抽象类可以有构造器</td><td>接口不能有构造器</td></tr><tr><td>字段声明</td><td>抽象类的字段声明可以是任意的</td><td>接口的字段默认都是static和final的</td></tr></tbody></table><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li><p>类变量：独立于方法之外的变量，用static修饰</p></li><li><p>实例变量：独立于方法之外的变量，没有用static修饰</p></li><li><p>成员变量：又称全局变量，可分为类变量和实例变量</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类包括四种：成员内部类、局部内部类、匿名内部类、静态内部类</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4></li><li><p>成员内部类定义为位于一个类的内部</p></li><li><p>成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）</p></li><li><p>外部类访问成员内部类成员时，必须先创建一个成员内部类对象，再通过指向这个对象的引用来访问</p></li><li><p>成员内部类依附于外部类而存在，如果要创建成员内部类对象，前提是必须存在一个外部类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClassTest</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 普通成员变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// 静态成员变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 同名变量</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InnerClassTest</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InnerClassTest</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">long</span> c)</span> &#123;<br>        <span class="hljs-built_in">this</span>(a);<br>        <span class="hljs-built_in">this</span>.c = c;<br>    &#125;<br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span> &#123; <span class="hljs-comment">// 内部类</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(a);<br>            System.out.println(b);<br>            System.out.println(InnerClassTest.<span class="hljs-built_in">this</span>.c); <span class="hljs-comment">// 访问外部类同名变量</span><br>            System.out.println(c); <span class="hljs-comment">// 访问内部变量</span><br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4></li><li><p>局部内部类是定义在一个方法或者一个作用域里面的类</p></li><li><p>访问仅限于方法内或作用域内</p><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4></li><li><p>指没有名字的内部类</p></li><li><p>使用前提条件：继承一个父类或者实现一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>;<br>    <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnonymityInnerClass</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Person...&quot;</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4></li><li><p>定义在一个类的内部，用static修饰</p></li><li><p>静态内部类不依赖于外部类，不能访问外部类中非静态成员变量和方法</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3></li><li><p>匿名内部类可以很方便的定义回调</p></li><li><p>内部类最吸引人的：每个内部类都能独自继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没影响</p></li><li><p>内部类有效实现了“多重继承”，优化Java中单继承的缺陷</p><h2 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h2></li></ul><p><strong>值传递：</strong>是指在函数调用时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数<br><strong>引用传递：</strong>是指在函数调用时将实际参数的地址直接传递到函数中，则在函数中对参数进行的修改，将影响到实际参数</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><strong>序列化：</strong>将对象写入到IO流中<br><strong>反序列化：</strong>从IO流中恢复对象<br><strong>实现方式：</strong></p><ul><li>实现<code>Serializable</code>接口</li><li>实现<code>Externalizable</code>接口</li></ul><p><strong>说明：</strong></p><ul><li><p>对象的类名、实例变量会被序列化</p></li><li><p>方法、类变量、<code>transient</code>实例变量都不会被序列化</p></li><li><p>某个变量不想被序列化，可以使用<code>transient</code>修饰</p></li><li><p>序列化对象的引用类型成员变量，必须是可序列化的否则会报错</p></li><li><p>反序列化时必须有序列化对象的<code>class</code>文件</p><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2></li><li><p><strong>深拷贝：</strong>对基本数据类型进行值传递；对引用数据类型，创建一个新对象，并复制其内容，两个引用指向两个对象，但对象的内容相同</p></li><li><p><strong>浅拷贝：</strong>对基本数据类型进行值传递；对引用数据类型复制一个引用指向原始引用对象，即复制的引用和原始引用指向同一个对象</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1656238538349-c58f550f-8a41-4df2-8865-d6d9cf585995.png#clientId=u53df3f19-1c59-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=698&id=u878e811b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=698&originWidth=694&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74195&status=done&style=none&taskId=u59dc4b32-9439-4310-9c0b-f7d266de203&title=&width=694" alt="image.png"></p><hr><h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><h2 id="常用的集合类"><a href="#常用的集合类" class="headerlink" title="常用的集合类"></a>常用的集合类</h2><ul><li>Map接口和Collection接口是所有集合框架的父接口</li><li>Collection接口不是Map的父接口</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1656249887891-7f5f02e7-698a-45d8-bd4b-ae772406d6c1.png#clientId=ufe945330-ab88-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=495&id=uc100b797&margin=%5Bobject%20Object%5D&name=image.png&originHeight=495&originWidth=936&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74443&status=done&style=none&taskId=u16e98cf8-9a1f-4f33-b5b8-5a23485da31&title=&width=936" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1656249966677-6a95b401-c4ab-408b-8e76-5ff5c1654d24.png#clientId=ufe945330-ab88-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=328&id=u4de0e1c8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=328&originWidth=986&originalType=binary&ratio=1&rotation=0&showTitle=false&size=44516&status=done&style=none&taskId=u2585481f-34a5-4f11-90e6-8131d90f211&title=&width=986" alt="image.png"></p><hr><h1 id="Java并发编程"><a href="#Java并发编程" class="headerlink" title="Java并发编程"></a>Java并发编程</h1><h2 id="用Java实现死锁，并给出避免死锁的解决方案"><a href="#用Java实现死锁，并给出避免死锁的解决方案" class="headerlink" title="用Java实现死锁，并给出避免死锁的解决方案"></a>用Java实现死锁，并给出避免死锁的解决方案</h2><h2 id="线程同步和线程调度相关的方法问题"><a href="#线程同步和线程调度相关的方法问题" class="headerlink" title="线程同步和线程调度相关的方法问题"></a>线程同步和线程调度相关的方法问题</h2><h3 id="什么是线程同步？什么是线程互斥？"><a href="#什么是线程同步？什么是线程互斥？" class="headerlink" title="什么是线程同步？什么是线程互斥？"></a>什么是线程同步？什么是线程互斥？</h3><ul><li>线程的互斥是指某一个资源只能被一个访问者访问，具有唯一性和排他性。但访问者对资源访问的顺序是乱序的。</li><li>线程的同步是在互斥的基础上，访问者的访问顺序是有序的。<h3 id="在Java程序中如何保证线程的运行安全"><a href="#在Java程序中如何保证线程的运行安全" class="headerlink" title="在Java程序中如何保证线程的运行安全"></a>在Java程序中如何保证线程的运行安全</h3></li></ul><p><strong>线程安全问题主要体现在原子性、可见性和有序性</strong>。</p><ul><li>原子性：一个或者多个操作在CPU执行的过程中不被中断的特性。线程切换带来的原子性问题。</li><li>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。缓存导致的可见性问题。</li><li>有序性：程序执行的顺序按照代码的先后顺序执行。编译优化带来的有序性问题。</li></ul><p>解决方法：</p><ul><li><p>原子性问题：可用JDK Atomic开头的原子类、 synchronized、 LOCK来解决。</p></li><li><p>可见性问题：可用synchronized、volatile、 LOCK 来解决。</p></li><li><p>有序性问题：可用<strong>Happens-Before</strong>规则来解决。</p><h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><h3 id="synchronized关键字三大特性是什么"><a href="#synchronized关键字三大特性是什么" class="headerlink" title="synchronized关键字三大特性是什么"></a>synchronized关键字三大特性是什么</h3><blockquote><p>面试时会将synchronized关键字和volatile关键字进行对比，synchronized关键字可以保证并发编程的三大特性：原子性、可见性和有序性；而volatile关键字只能保证可见性和有序性，称之为轻量级的synchronized。</p></blockquote></li><li><p>原子性：一个或多个操作要么全部执行成功，要么全部执行失败。synchronized关键字可以保证只有一个线程拿到锁，访问共享资源。</p></li><li><p>可见性：当一个线程对共享变量进行修改后，其他线程可以立刻看到。执行synchronized时， 会对应执行lock、unlock原子操作，保证可见性。</p></li><li><p>有序性：程序的执行顺序会按照代码的先后顺序执行。</p><h3 id="synchronized关键字可以实现什么类型的锁"><a href="#synchronized关键字可以实现什么类型的锁" class="headerlink" title="synchronized关键字可以实现什么类型的锁"></a>synchronized关键字可以实现什么类型的锁</h3></li><li><p>悲观锁：synchronized关键字实现的是悲观锁，每次访问共享资源时都会上锁。</p></li><li><p>非公平锁：synchronized关键字实现的是非公平锁， 即线程获取锁的顺序并不一定是按照线程阻塞的顺序。</p></li><li><p>可重入锁：synchronized关键字实现的是可重入锁，即已经获取锁的线程可以再次获取锁。</p></li><li><p>独占锁或者排他锁：synchronized关键字实现的是独占锁，即该锁只能被一个线程所持有，其他线程均被阻塞。</p><h3 id="synchronized关键字的使用方式"><a href="#synchronized关键字的使用方式" class="headerlink" title="synchronized关键字的使用方式"></a>synchronized关键字的使用方式</h3><p>主要有三种使用方式：<strong>修饰普通同步方法</strong>、<strong>修饰静态同步方法</strong>、<strong>修饰同步方法块</strong>。</p></li><li><p>修饰普通同步方法（实例方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 共享资源</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>            add();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">SynTest</span> <span class="hljs-variable">synTest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynTest</span>();<br>        <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(synTest);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(synTest);<br>        <br>        t1.start();<br>        t2.start();<br>        <br>        t1.join();<br>        t2.join();<br>        <br>        System.out.println(i); <span class="hljs-comment">// 2000</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修饰静态同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 共享资源</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>            add();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// SynTest synTest = new SynTest();</span><br>        <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynTest</span>());<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynTest</span>());<br>        <br>        t1.start();<br>        t2.start();<br>        <br>        t1.join();<br>        t2.join();<br>        <br>        System.out.println(i); <span class="hljs-comment">// 2000</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修饰同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 共享资源</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 其他操作</span><br>        <br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// SynTest synTest = new SynTest();</span><br>        <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynTest</span>());<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynTest</span>());<br>        <br>        t1.start();<br>        t2.start();<br>        <br>        t1.join();<br>        t2.join();<br>        <br>        System.out.println(i); <span class="hljs-comment">// 2000</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="synchronized关键字的底层原理"><a href="#synchronized关键字的底层原理" class="headerlink" title="synchronized关键字的底层原理"></a>synchronized关键字的底层原理</h3><p>Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，代码块同步使用的是monitorenter和monitorexit指令实现的，而方法同步是通过Access flags后面的标识来确定该方法是否为同步方法。</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><h3 id="volatile的作用是什么"><a href="#volatile的作用是什么" class="headerlink" title="volatile的作用是什么"></a>volatile的作用是什么</h3><p>volatile是一个轻量级的synchronized，一般作用于变量，在多处理器开发的过程中保证了内存的可见性。相比于synchronized关键字，其执行成本更低，效率更高。</p><h3 id="volatile关键字的特性有哪些"><a href="#volatile关键字的特性有哪些" class="headerlink" title="volatile关键字的特性有哪些"></a>volatile关键字的特性有哪些</h3><blockquote><p>并发编程的三大特性为可见性、有序性和原子性。通常来讲volatile可以保证可见性和有序性。</p></blockquote></li><li><p>可见性：volatile可以保证不同线程对共享变量进行操作时的可见性。</p></li><li><p>有序性：volatile可以通过禁止指令重排序进而保证有序性。</p></li><li><p>原子性：对于单个的volatile修饰的变量的读写是可以保证原子性的，但对于i++这种复合操作并不能保证原子性。即volatile基本上不具备原子性。</p><h3 id="为什么代码会重排序"><a href="#为什么代码会重排序" class="headerlink" title="为什么代码会重排序"></a>为什么代码会重排序</h3><p>计算机在执行程序的过程中，编译器和处理器通常会对指令进行重排序，这样做的目的是为了提高性能。<br>指令重排序一般分为<strong>编译器优化重排</strong>、<strong>指令并行重排</strong>和<strong>内存系统重排。</strong></p></li><li><p>编译器优化重排：编译器在不改变单线程程序语义的情况下，可以对语句的执行顺序进行重排序。</p></li><li><p>指令并行重排：现代处理器多采用指令级并行技术来将多条指令重叠执行。对于不存在<strong>数据依赖</strong>的程序，处理器可以对机器指令的执行顺序进行重新排列。</p></li><li><p>内存系统重排：因为处理器使用缓存和读/写缓冲区，使得加载（load）和存储（store）看上去像是在乱序执行。</p><h3 id="重排序会引发什么问题"><a href="#重排序会引发什么问题" class="headerlink" title="重排序会引发什么问题"></a>重排序会引发什么问题</h3><p>在多线程代码中，重排序会破坏多线程程序的语义。</p><h3 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h3></li><li><p>volatile主要是保证内存的可见性，即变量在寄存器中的内存是不确定的，需要从主存中读取。synchronized主要是解决多个线程访问资源的同步性。</p></li><li><p>volatile作用于变量，synchronized作用于代码块或者方法。</p></li><li><p>volatile仅可以保证数据的可见性，不能保证数据的原子性。synchronized可以保证数据的可见性和原子性。</p></li><li><p>volatile不会造成线程的阻塞，synchronized会造成线程的阻塞。</p><h2 id="CurrentHashMap"><a href="#CurrentHashMap" class="headerlink" title="CurrentHashMap"></a>CurrentHashMap</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1659337132321-2133429a-8a3e-429b-aff6-c6a4d7843a8e.png#clientId=u1e77df9b-6dc6-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=301&id=u52932632&margin=%5Bobject%20Object%5D&name=image.png&originHeight=301&originWidth=506&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10148&status=done&style=none&taskId=u36bff6c3-ccd4-4c5f-8477-83c66cf7924&title=&width=506" alt="image.png"></p><h3 id="什么是CurrentHashMap？相比于HashMap和HashTable有什么优势？"><a href="#什么是CurrentHashMap？相比于HashMap和HashTable有什么优势？" class="headerlink" title="什么是CurrentHashMap？相比于HashMap和HashTable有什么优势？"></a>什么是CurrentHashMap？相比于HashMap和HashTable有什么优势？</h3><p>CocurrentHashMap可以看作_<strong>线程安全</strong>_且高效的HashMap，相比于HashMap具有线程安全的优势，相比于HashTable具有效率高的优势。</p><h3 id="Java中CurrentHashMap是如何实现的"><a href="#Java中CurrentHashMap是如何实现的" class="headerlink" title="Java中CurrentHashMap是如何实现的"></a>Java中CurrentHashMap是如何实现的</h3><blockquote><p>注意：JDK 1.7和JDK1.8中的实现存在差异。</p></blockquote></li><li><p>JDK 1.7</p></li></ul><p>在JDK1.7版本中，ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry数组组成，Segment存储的是链表数组的形式，如图所示。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658906869689-c522e379-464d-4fac-8b8d-bc5b89cbce48.png#clientId=u45035bbf-2508-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=785&id=u843e5c79&margin=%5Bobject%20Object%5D&name=image.png&originHeight=785&originWidth=1161&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49283&status=done&style=none&taskId=u9cd1823b-675c-4e8e-8957-7545af12ff2&title=&width=1161" alt="image.png"><br>从上图可以看出，ConcurrentHashMap定位一个元素的过程需要两次hash的过程，第一次hash的目的是定位到Segment，第二次hash的目的是定位到链表的头部。两次hash所使用的时间比一次hash的时间要长，但这样做可以在写操作时，只对元素所在的Segment加锁，不会影响到其他Segment，这样可以大大提高并发能力。</p><ul><li>JDK 1.8</li></ul><p>JDK1.8不在采用Segment的结构，而是使用Node数组+链表/红黑树的数据结构来实现的(和HashMap一样，<strong>链表节点个数大于8，或Node数组大于64时，链表会转换为红黑树</strong>)。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658907006317-7bafc8ec-6733-44c8-a83f-3638975ac3cf.png#clientId=u45035bbf-2508-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=720&id=u66517a2e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=720&originWidth=1083&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111411&status=done&style=none&taskId=u8f960b47-9d57-49ec-83c0-5a5ca5c5623&title=&width=1083" alt="image.png"><br>从上图可以看出，对于ConcurrentHashMap的实现，JDK1.8的实现方式可以<strong>降低锁的粒度</strong>，因为JDK1.7所实现的ConcurrentHashMap的锁的粒度是基于Segment，而一个Segment包含多个HashEntry。</p><h3 id="ConcurrentHashMap初始容量和扩容"><a href="#ConcurrentHashMap初始容量和扩容" class="headerlink" title="ConcurrentHashMap初始容量和扩容"></a>ConcurrentHashMap初始容量和扩容</h3><ul><li>初始容量为16</li><li>每次扩容为之前的两倍<h3 id="键值是否可以为空"><a href="#键值是否可以为空" class="headerlink" title="键值是否可以为空"></a>键值是否可以为空</h3>ConcurrentHashMap中的key和value均不可以为null，如果插入数据时只要有一个为空则会报空指针异常。这一点与HashMap不同。</li></ul><p><strong>原因如下</strong>：ConcurrentHashMap是在多线程场景下使用的，如果ConcurrentHashMap.get(key)的值为null，那么无法判断到底是key对应的value的值为null还是不存在对应的key值。而在单线程场景下的HashMap中，可以使用containsKey(key)来判断到底是不存在这个key还是key对应的value的值为null。在多线程的情况下使用containsKey(key)来做这个判断是存在问题的，因为在containsKey(key)和ConcurrentHashMap.get(key)两次调用的过程中，key的值经发生了改变。</p><h3 id="ConcurrentHashMap适用场景"><a href="#ConcurrentHashMap适用场景" class="headerlink" title="ConcurrentHashMap适用场景"></a>ConcurrentHashMap适用场景</h3><p>用于并发场景下，更进一步可以用在创建普通POJO对象的场景中，JVM的GC会自动回收无效的引用；不适合保存创建计算机资源（如线程池、IO等）的场景，因为这些资源是有限的。<br>例子：<br>用于保存在线用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在线用户管理类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserManager</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;String, User&gt; userMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-comment">// 当用户登入时调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUserSignIn</span><span class="hljs-params">(String sessionId, User user)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userMap.put(sessionId, user);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 当用户登出或超时时调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUserSignOut</span><span class="hljs-params">(String sessionId)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userMap.remove(sessionId);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">getUser</span><span class="hljs-params">(String sessionId)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.userMap.get(sessionId);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当有很多用户同时登入和登出时，两个方法就会有很多线程同时调用。</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal"></a>什么是ThreadLocal</h3><p>ThreadLocal是JDK中java.lang包下的一个类，ThreadLocal 为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量，并且不会和其他线程的局部变量冲突，实现了线程间的数据隔离。<br>总结就是ThreadLocal是一个关于创建线程局部变量的类。<br>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。</p><h3 id="ThreadLocal的应用场景"><a href="#ThreadLocal的应用场景" class="headerlink" title="ThreadLocal的应用场景"></a>ThreadLocal的应用场景</h3><ul><li>保存线程上下文信息，在需要的地方可以获取</li><li>线程间数据隔离</li><li>数据库连接<h3 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h3><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1659427849422-4f9f3496-d301-4c94-8176-496ff8503ff9.png#clientId=ud96b3449-5125-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=527&id=u0ff5fe23&margin=%5Bobject%20Object%5D&name=image.png&originHeight=527&originWidth=829&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66942&status=done&style=none&taskId=u669ee662-1769-4356-9045-a2cb56f9833&title=&width=829" alt="image.png"><br>每个线程Thread都有一个ThreadLocalMap，ThreadLocalMap中保存着所有的ThreadLocal，是真正承载数据的一个Entry数组，Entry的key是ThreadLocal对象的<strong>弱引用</strong>。即ThreadLocal的值时放入了一当前线程的一个ThreadLocalMap实例中。故只能在本线程中访问，其他线程无法访问。<blockquote><p>补充：弱引用一般是用来描述非必需对象的，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。<strong>当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</strong>。</p></blockquote></li></ul><h3 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h3><p>结论是使用不当会造成内存泄漏。ThreadLocalMap中对ThreadLocal对象的引用被设计为弱引用，就是防止在ThreadLocal对象在栈中被清除后而在堆中的对象发生内存泄漏。即使设计成这样，依然可能发生内存泄漏，如线程不被回收。什么情况下有可能会发生线程不被回收呢？在线程池中，由于线程每次使用完之后会放回线程池，由于线程没有被销毁，所以值一直存在，这样就发生了内存泄漏。</p><h3 id="内存泄漏解决办法"><a href="#内存泄漏解决办法" class="headerlink" title="内存泄漏解决办法"></a>内存泄漏解决办法</h3><p>其实ThreadLocal在设计的时候已经考虑到了这种情况，在调用set()、get()、 remove() 等方法时就会清理掉key为null的记录，所以在使用完ThreadLocal后最好手动调用remove()方法。</p><h3 id="为什么要将ThreadLocalMap中的key设计成ThreadLocal的弱引用"><a href="#为什么要将ThreadLocalMap中的key设计成ThreadLocal的弱引用" class="headerlink" title="为什么要将ThreadLocalMap中的key设计成ThreadLocal的弱引用"></a>为什么要将ThreadLocalMap中的key设计成ThreadLocal的弱引用</h3><p>如果ThreadLocalMap的key是强引用，同样会发生内存泄漏的。如果ThreadLocalMap的key是强引用，引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，发生内存泄漏。<br>如果是弱引用的话，引用的ThreadLocal的对象被回收了，即使没有手动删除，ThreadLocal也会被<br>回收。value也会在ThreadLocalMap调用set()、get()、 remove() 的时候会被清除。<br>所以两种方案比较下来，还是ThreadLoaclMap的key为弱引用好些。</p><hr><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="HotSpot虚拟机"><a href="#HotSpot虚拟机" class="headerlink" title="HotSpot虚拟机"></a>HotSpot虚拟机</h2><h3 id="创建对象时内存的分配方式"><a href="#创建对象时内存的分配方式" class="headerlink" title="创建对象时内存的分配方式"></a>创建对象时内存的分配方式</h3><p>创建对象时根据Java内存是否完整，分配方式有<strong>指针碰撞（完整）</strong>和<strong>空闲列表（不完整）</strong>。<br><strong>（1）指针碰撞</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657075232431-2957e6e2-f6fb-46c9-b7e7-0f6116bf1f58.png#clientId=ucd4d0f03-b44f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=295&id=uadf0d605&margin=%5Bobject%20Object%5D&name=image.png&originHeight=295&originWidth=998&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29364&status=done&style=none&taskId=u2b63b606-ec86-49ec-9e4d-c60527200fb&title=&width=998" alt="image.png"><br><strong>注：</strong>选择哪种分配方式由Java堆是否完整决定，Java堆是否完整由所采用的垃圾收集器是否带有压缩整理功能决定。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头、实例数据、对齐填充。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657078043672-b407d9b2-2ea3-4581-a935-16207d307e75.png#clientId=uef0d43a0-2438-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc1987776&margin=%5Bobject%20Object%5D&originHeight=268&originWidth=223&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u492f9c3c-35ff-40f6-b493-f915e7e1d44&title="></p><ul><li><p><strong>对象头（Object Header）</strong>：包含两部分信息，一部分用于存储自身的运行时数据，如哈希码、GC分带年龄、锁状态标志、线程持有的锁、偏向线程ID等；另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过该指针来确定这个对象是哪个类的实例。</p></li><li><p><strong>实例数据（Instance Data）</strong>：对象真正存储的有效信息，也是代码中所定义的各种类型的字段内容。</p></li><li><p><strong>对齐填充（Padding）</strong>：为了字节填充，填充的数据，不是必须的。</p><h3 id="对象的访问方式"><a href="#对象的访问方式" class="headerlink" title="对象的访问方式"></a>对象的访问方式</h3><p>Java程序通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式有使用<strong>句柄</strong>和<strong>直接指针</strong>。</p></li><li><p><strong>句柄：</strong>Java堆中会划分出一块内存来作为句柄，reference中存储的是对象的句柄地址， 而句柄中包含了对象实例数据与类型数据各自的具体地址信息。通过使用句柄访问对象，reference中存储的是稳定的句柄地址，在对象移动时（垃圾回收时会经常移动对象）只会改变句柄中的实例数据指针，无需改变reference。</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657094320326-950c7c8e-c2da-4a52-847d-8efb787f5e1c.png#clientId=uef0d43a0-2438-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=574&id=udf0cbdbd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=574&originWidth=1120&originalType=binary&ratio=1&rotation=0&showTitle=false&size=232096&status=done&style=none&taskId=u8801258c-0eb5-4a5f-9779-b275f64f9cd&title=&width=1120" alt="image.png"></p><ul><li><strong>直接指针</strong>：使用直接指针访问对象，reference中存储的是对象地址，而Java堆中对象的布局需要考虑如何放置访问类型数据的相关信息。使用直接指针访问对象省了一次指针定位的时间开销，速度更快。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657094576572-a8bb76ab-a6dc-4e45-bd47-f18bce9702a9.png#clientId=uef0d43a0-2438-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=558&id=ub108f54e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=558&originWidth=1125&originalType=binary&ratio=1&rotation=0&showTitle=false&size=199935&status=done&style=none&taskId=u9f236c2f-1274-4ac2-8489-2ba68cf66a2&title=&width=1125" alt="image.png"></p><h2 id="Java内存泄漏"><a href="#Java内存泄漏" class="headerlink" title="Java内存泄漏"></a>Java内存泄漏</h2><h3 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h3><p>内存泄漏指对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为在被引用着。<br>在Java中，<strong>内存泄漏</strong>就是存在一些被分配的对象，这些对象有下面两个特点：</p><ul><li><strong>首先</strong>，这些对象是可达的，即<strong>在有向图中，存在通路可以与其相连</strong>；</li><li><strong>其次</strong>，<strong>这些对象是无用的，即程序以后不会再使用这些对象</strong>。</li></ul><p>如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。<br>简单来说就是申请内存使用完了不进行释放。</p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><ul><li><p><strong>静态集合类引起内存泄漏</strong>，因为静态集合的生命周期与JVM一致，所以静态集合引用的对象不能被释放。</p></li><li><p><strong>单例模式导致内存泄漏</strong>，因为单例模式的静态特性，它的生命周期和JVM的生命周期一致，如果单例对象持有外部对象的引用，这个对象也不会被回收。</p></li><li><p><strong>内部类的对象被长期持有</strong>，那么内部类对象所属的外部类对象不能被回收。</p></li><li><p><strong>数据库连接、网络连接等各种连接没有显式释放导致内存泄漏</strong>。</p></li><li><p><strong>改变哈希值</strong>，例如在一个对象存储到HashSet后，改变了对象中参与计算哈希值的字段，那么会导致对象的哈希值发生变化，和之前存入HashSet的哈希值不同，也就无法通过当前对象的引|用在HashSet中找到这个对象，无法从HashSet中删除对象，造成内存泄漏，这也是为什么通常利用String类型的变量当作HashMap的key,因为String类型是不可变的。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>写代码时尽量避免上述会造成内存泄漏的情况。</p><h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><h3 id="什么是内存溢出"><a href="#什么是内存溢出" class="headerlink" title="什么是内存溢出"></a>什么是内存溢出</h3><p>指程序运行过程中无法申请到足够的内存导致的错误。</p><h3 id="产生原因-1"><a href="#产生原因-1" class="headerlink" title="产生原因"></a>产生原因</h3></li><li><p>内存加载的数据量太大，内存不够用了</p></li><li><p>代码中存在死循环或循环产生大量对象</p></li><li><p>启动参数内存值设置过小</p></li><li><p>长期的内存泄漏也会导致内存溢出</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3></li><li><p>修改<strong>JVM启动参数</strong>，增加内存</p></li><li><p>使用<strong>内存查看工具</strong>动态查看内存使用情况</p></li><li><p>对代码进行排查，重点排查有没有上述提到的造成常见内存溢出情景的代码</p><h2 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h2><p>当线程所请求的栈深度超过虚拟机所允许的最大深度后，会发生栈溢出，即<code>StackOverflowError</code> ,比如在方法递归调用时就可能发生栈内存溢出，可以通过<strong>JVM参数-Xss</strong>来调整栈内存的大小来避免栈内存溢出，但如果是代码问题光调整栈内存大小肯定是不够的，还是要从根本解决问题。</p><h2 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h2><h3 id="如何判断对象是否可以回收"><a href="#如何判断对象是否可以回收" class="headerlink" title="如何判断对象是否可以回收"></a>如何判断对象是否可以回收</h3><p>判断对象是否死亡的常见方法主要有<strong>引用计数法</strong>和<strong>可达性分析法</strong>两种。</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器就会加1；当引用失效时，计数器就减1，当计数器为0就是没有被使用的对象，但主流的Java虚拟机并没有选择用弓|用计数法来管理内存，因为无法解决对象之间相互循环引用的问题，就是两个对象相互引用，除此之外，两个对象并没有其他引用，这两个对象已经不可能被访问了，但他们的弓|用计数都不为0，所以无法被垃圾收集器回收。</p><h4 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h4><p>可达性分析法就是通过一系列被称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径被称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明该对象是不可用的，也就是可回收的，如下图，对象object 5、object 6、object 7虽然有关联，但他们到GC Roots是不可达的，所以也会判定是可以回收的，这样解决了对象之间相互引用导致不能回收的问题。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657267387921-d1f582e0-0be8-4736-9a13-39c78503755a.png#clientId=udfed2b78-8c5f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=653&id=u1dd1d734&margin=%5Bobject%20Object%5D&name=image.png&originHeight=653&originWidth=1156&originalType=binary&ratio=1&rotation=0&showTitle=false&size=291421&status=done&style=none&taskId=u33dc7fb4-4ca9-4f30-b2ba-528109f8135&title=&width=1156" alt="image.png"></p></li></ul><p><strong>注：</strong>在Java语言中，可以作为GC Roots的对象主要有以下几种：</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的属性</li><li>本地方法栈中Native中引用的对象<h3 id="JVM中的方法区（永久代）会发生垃圾回收吗？元空间会发生垃圾回收吗？"><a href="#JVM中的方法区（永久代）会发生垃圾回收吗？元空间会发生垃圾回收吗？" class="headerlink" title="JVM中的方法区（永久代）会发生垃圾回收吗？元空间会发生垃圾回收吗？"></a>JVM中的方法区（永久代）会发生垃圾回收吗？元空间会发生垃圾回收吗？</h3></li></ul><ol><li>永久代概念是HotSpot虚拟机独有</li><li>JDK1.8之前JVM存在永久代，JDK1.8被元空间替代；永久代和元空间都是方法区的具体实现，方法区只是一个规范。</li><li>在永久代中发生的内存回收主要是<strong>常量池的回收</strong>和<strong>类型的卸载</strong>。</li><li>判断一个类型是否可以回收需要看以下方面：</li></ol><ul><li>该类型所有实例都被回收</li><li>加载该类的类加载器已经被回收</li><li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul><ol start="5"><li>在JDK1.8中使用元空间取代永久代，主要是因为：永久代使用的是设定好的虚拟机内存，无法动态扩展内存空间，当加载过多的类时可能发生OOM，并且永久代的内存大小设置也是难以确定的，所以对永久代的调优比较困难；而元空间的出现是为了解决永久代的问题，因为元空间不再使用虚拟机的内存，而是使用本地内存，本地内存可以自动扩展调节，内存不足也不会出发Full GC。<h3 id="主动通知虚拟机进行垃圾回收"><a href="#主动通知虚拟机进行垃圾回收" class="headerlink" title="主动通知虚拟机进行垃圾回收"></a>主动通知虚拟机进行垃圾回收</h3>可以通过调用<code>System.gc()</code>方法通知虚拟机进行垃圾回收，但Java虚拟机规范并不能保证一定会执行。<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3></li></ol><ul><li><p>标记——清除算法</p></li><li><p>标记——复制算法</p></li><li><p>标记——整理算法</p></li><li><p>分代收集算法</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>垃圾回收算法是内存回收的方法论，垃圾收集器则是内存回收的具体实现。Java规范中并没有对垃圾收集器的实现有任何规范，所以不用的厂商、不同的版本的虚拟机提供的垃圾收集器是不同的。</p><h2 id="关于类加载"><a href="#关于类加载" class="headerlink" title="关于类加载"></a>关于类加载</h2><p>类加载机制：虚拟机把类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p><h3 id="简述类的生命周期"><a href="#简述类的生命周期" class="headerlink" title="简述类的生命周期"></a>简述类的生命周期</h3><p>类从被加载到虚拟机内存中开始，到卸载为止，生命周期包括：<strong>加载、验证、准备、解析、初始化、使用和卸载</strong>。其中验证、准备和解析统称为连接。</p><h3 id="简述类的加载过程"><a href="#简述类的加载过程" class="headerlink" title="简述类的加载过程"></a>简述类的加载过程</h3><p>类的加载过程也就是类的生命周期的前五部分，加载、验证、准备、解析和初始化。</p><h3 id="类加载器有哪些"><a href="#类加载器有哪些" class="headerlink" title="类加载器有哪些"></a>类加载器有哪些</h3><p>类加载器的作用就是将类加载到虚拟机的内存中。<br>JVM主要提供三个类加载器：</p></li><li><p>启动类加载器（Bootstrap ClassLoader）</p></li><li><p>扩展类加载器（Extension ClassLoader）</p></li><li><p>应用程序类加载器（Application ClassLoader）</p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>双亲委派机制是指如果一个类加载器收到 了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是这样，所以所有的加载请求最终都应该传送到顶层的启动类加载容器，只有当父类加载器无法完成加载时，子加载器才会尝试自己去加载，如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657678603571-2ff051ea-bf2e-4847-ace4-25a194174627.png#clientId=u005da07f-0361-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=537&id=ue188f49b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=790&originWidth=798&originalType=binary&ratio=1&rotation=0&showTitle=false&size=422313&status=done&style=none&taskId=ud973c139-0ea8-48a8-945c-1f0557874e9&title=&width=542" alt="image.png"></p><h2 id="JVM调优相关"><a href="#JVM调优相关" class="headerlink" title="JVM调优相关"></a>JVM调优相关</h2><h3 id="JVM调优的目标"><a href="#JVM调优的目标" class="headerlink" title="JVM调优的目标"></a>JVM调优的目标</h3><p>大多数时候，JVM调优最主要的目标是<strong>停顿时间</strong>和<strong>吞吐量</strong>，还有一个指标是<strong>内存占用</strong>。</p><h3 id="JVM调优策略"><a href="#JVM调优策略" class="headerlink" title="JVM调优策略"></a>JVM调优策略</h3><p>JVM调优的具体策略基本都是围绕两部分展开的，即<strong>内存</strong>和<strong>垃圾回收器</strong>。</p><h3 id="JVM调优步骤"><a href="#JVM调优步骤" class="headerlink" title="JVM调优步骤"></a>JVM调优步骤</h3><p>JVM调优应先确定瓶颈及调优目标，如下：</p></li><li><p>分析GC日志及通过虚拟机监控的命令查看系统运行情况，找出哪里出了问题</p></li><li><p>确定调优的目标</p></li><li><p>确定调优策略及调整相关参数，这是个不断对比分析和调整的过程，很难一步到位</p></li></ul><hr><h1 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h1><h2 id="MySQL常用的存储引擎以及区别"><a href="#MySQL常用的存储引擎以及区别" class="headerlink" title="MySQL常用的存储引擎以及区别"></a>MySQL常用的存储引擎以及区别</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB是MySQL的默认存储引擎，支持事务、行锁和外键等操作。</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM是MySQL5.1版本前的默认存储引擎，MyISAM的并发性比较差，不支持事务和外键等操作，默认的锁的粒度为表级锁。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table><thead><tr><th></th><th><strong>InnoDB</strong></th><th><strong>MyISAM</strong></th></tr></thead><tbody><tr><td><strong>外键</strong></td><td>支持</td><td>不支持</td></tr><tr><td><strong>事务</strong></td><td>支持</td><td>不支持</td></tr><tr><td><strong>锁</strong></td><td>支持表锁和行锁</td><td>支持表锁</td></tr><tr><td><strong>可恢复性</strong></td><td>根据事务日志进行恢复</td><td>无事务日志</td></tr><tr><td><strong>表结构</strong></td><td>数据和索引是集中存储的，文件格式分别为<code>.ibd</code>和<code>.frm</code></td><td>数据和索引是分开存储的，数据是<code>.MYD</code>，索引是<code>.MYI</code></td></tr><tr><td><strong>查询性能</strong></td><td>一般情况相比于MyISAM较差</td><td>一般情况相比于InnoDB好些</td></tr><tr><td><strong>索引</strong></td><td>聚簇索引</td><td>非聚簇索引</td></tr></tbody></table><h2 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h2><ul><li>第一范式：确保每列保持原子性， 数据表中的所有字段值都是不可分解的原子值。</li><li>第二范式：确保表中的每列都和主键相关。</li><li>第三范式：确保每列都和主键列直接相关而不是间接相关。<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3>数据库索引是排好序的数据结构，具体是对数据库表的一列或者多列的值进行排序的一种结构。<h3 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h3>索引的一个主要目的就是加快检索表中数据，实现快速访问数据表中的特定信息。<h3 id="什么是最左前缀匹配原则"><a href="#什么是最左前缀匹配原则" class="headerlink" title="什么是最左前缀匹配原则"></a>什么是最左前缀匹配原则</h3>MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。<strong>而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。</strong><br>这里举个例子，如User表的name和city组合为联合索引就是(name, city)。有如下查询语句，后跟索引命中情况：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span>xx <span class="hljs-keyword">and</span> city<span class="hljs-operator">=</span>yy; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 可以命中索引，原因是查询条件匹配索引的最左边列<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span>xx; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 命中索引<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> city<span class="hljs-operator">=</span>yy; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 无法命中索引，原因是索引最左边列未在查询条件中<br></code></pre></td></tr></table></figure>需要补充的是，查询的时候如果索引列的条件均用上，但最左边索引在查询条件中不在第一列时也能命中索引，原因是现在的查询引擎会自动优化为匹配联合索引的顺序。<br>另外，总结就是最左匹配原则是从最左边为起点开始连续匹配，遇到范围查询(&lt;、&gt;、between、like)会停止匹配。</li></ul><h2 id="数据库的事务"><a href="#数据库的事务" class="headerlink" title="数据库的事务"></a>数据库的事务</h2><h3 id="什么是数据库的事务"><a href="#什么是数据库的事务" class="headerlink" title="什么是数据库的事务"></a>什么是数据库的事务</h3><p><strong>数据库事务( transaction)<strong>是访问并可能操作各种数据项的一个</strong>数据库操作序列</strong>，<strong>这些操作要么全部执行，要么全部不执行</strong>，是一个<strong>不可分割</strong>的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。</p><h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><p>事务的四大特性即通常所说的ACID(Atomicity原子性、Consistency一致性、Isolation隔离性、Durability持久性)。</p><ul><li><p><strong>原子性</strong>：原子性是指包含事务的操作要么全部执行成功，要么全部失败回滚。</p></li><li><p><strong>一致性</strong>：一致性指事务在执行前后状态是一致的。</p></li><li><p><strong>隔离性</strong>：一个事务所进行的修改在最终提交之前，对其他事务是不可见的。</p></li><li><p><strong>持久性</strong>：数据一旦提交，其所作的修改将永久地保存到数据库中。</p><h3 id="数据库的并发一致性问题"><a href="#数据库的并发一致性问题" class="headerlink" title="数据库的并发一致性问题"></a>数据库的并发一致性问题</h3><p>当多个事务并发执行时，可能会出现以下问题：</p></li><li><p><strong>脏读</strong>：事务A更新了数据，但还没有提交，这时事务B读取到事务A更新后的数据，然后事务A回滚了，事务B读取到的数据就成为脏数据了。</p></li><li><p><strong>不可重复读</strong>：事务A对数据进行多次读取，事务B在事务A多次读取的过程中执行了更新操作并提交了，导致事务A多次读取到的数据并不一致。</p></li><li><p><strong>幻读</strong>：事务A在读取数据后，事务B向事务A读取的数据中插入了几条数据，事务A再次读取数据时发现多了几条数据，和之前读取的数据不一致。</p></li><li><p><strong>丢失修改</strong>：事务A和事务B都对同一个数据进行修改，事务A先修改，事务B随后修改，事务B的修改覆盖了事务A的修改。</p></li></ul><p><strong>不可重复读</strong>和<strong>幻读</strong>看起来比较像，它们主要的区别是：在<strong>不可重复读</strong>中，发现数据不一致主要是数据被更新了。在<strong>幻读</strong>中，发现数据不一致主要是数据增多或者减少了。</p><h3 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h3><p>较低级别的隔离通常可以执行更高的并发，系统的开销也越低。下列隔离级别由低到高。</p><ul><li>**未提交读(READ UNCOMMITTED)**：一个事务在提交前，它的修改对其他事务也是可见的。</li><li>**提交读(READ COMMITTED)**：一个事务提交之后，它的修改才能被其他事务看到。</li><li>**可重复读(REPEATABLE READ)**：在同一个事务中多次读取到的数据是一致的。</li><li>**串行化(SERIALIZABLE)**：需要加锁实现，会强制事务串行执行。</li></ul><p>数据库的隔离级别分别可以解决数据库的脏读、不可重复读、幻读等问题。</p><table><thead><tr><th><strong>隔离级别</strong></th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th></tr></thead><tbody><tr><td><em><strong>未提交读</strong></em></td><td>允许</td><td>允许</td><td>允许</td></tr><tr><td><em><strong>提交读</strong></em></td><td>不允许</td><td>允许</td><td>允许</td></tr><tr><td><em><strong>可重复读</strong></em></td><td>不允许</td><td>不允许</td><td>允许</td></tr><tr><td><em><strong>串行化</strong></em></td><td>不允许</td><td>不允许</td><td>不允许</td></tr></tbody></table><p><strong>MySQL的默认隔离级别是可重复读。</strong></p><h3 id="隔离级别是如何实现的"><a href="#隔离级别是如何实现的" class="headerlink" title="隔离级别是如何实现的"></a>隔离级别是如何实现的</h3><p>事务的隔离机制主要是依靠锁机制和MVCC(多版本并发控制)实现的，提交读和可重复读可以通过MVCC实现，串行化可以通过锁机制实现。</p><h2 id="数据库的锁"><a href="#数据库的锁" class="headerlink" title="数据库的锁"></a>数据库的锁</h2><h3 id="什么是数据库的锁"><a href="#什么是数据库的锁" class="headerlink" title="什么是数据库的锁"></a>什么是数据库的锁</h3><p>当数据库有并发事务的时候，保证数据访问顺序的机制称为锁机制。</p><h3 id="数据库的锁与隔离级别的关系"><a href="#数据库的锁与隔离级别的关系" class="headerlink" title="数据库的锁与隔离级别的关系"></a>数据库的锁与隔离级别的关系</h3><table><thead><tr><th><strong>隔离级别</strong></th><th><strong>实现方式</strong></th></tr></thead><tbody><tr><td>未提交读</td><td>最低级别的隔离特性，无需加锁</td></tr><tr><td>提交读</td><td>读取数据时加共享锁，读取数据后释放共享锁</td></tr><tr><td>可重复读</td><td>读取数据时加共享锁，事务结束后释放共享锁</td></tr><tr><td>串行化</td><td>锁定整个范围的键，一直持有锁直到事务结束</td></tr></tbody></table><h3 id="数据库锁的类型有哪些"><a href="#数据库锁的类型有哪些" class="headerlink" title="数据库锁的类型有哪些"></a>数据库锁的类型有哪些</h3><p>按照锁的粒度，MySQL主要有以下类别的锁，各自的特点如表所示：</p><table><thead><tr><th><strong>锁类别</strong></th><th><strong>资源开销</strong></th><th><strong>加锁速度</strong></th><th><strong>是否会出现死锁</strong></th><th><strong>锁的粒度</strong></th><th><strong>并发度</strong></th></tr></thead><tbody><tr><td><strong>表级锁</strong></td><td>小</td><td>快</td><td>不会</td><td>大</td><td>低</td></tr><tr><td><strong>行级锁</strong></td><td>大</td><td>慢</td><td>会</td><td>小</td><td>高</td></tr></tbody></table><p>拓展：</p><ol><li>表级锁会在加锁时获取到全部的锁，要么全部满足，要么等待，所以不会产生死锁；InnoDB存储引擎中，锁都是逐步获得的，所以会存在死锁问题。</li><li>行级锁由于不合理的加锁顺序，可能会产生死锁。</li><li>MyISAM默认也仅支持表级锁；InnoDB默认采用行级锁。</li></ol><p>从锁的类别上可以将锁分为共享锁和排它锁：</p><ul><li>共享锁：共享锁又称读锁，简写为S锁，一个事务对一个数据对象加了S锁，可以对这个数据对象进行读取操作，但不能进行更新操作。并且在加锁期间其他事务只能对这个数据对象加S锁，不能加X锁。</li><li>排他锁：排他锁又称为写锁，简写为X锁，一个事务对一个数据对象加了X锁，可以对这个对象进行读取和更新操作，加锁期间，其他事务不能对该数据对象进行加X锁或S锁。<h2 id="数据库的优化"><a href="#数据库的优化" class="headerlink" title="数据库的优化"></a>数据库的优化</h2><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3>见博客：<a href="https://miderl.github.io/2022/07/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/">数据库的分库分表</a></li></ul><hr><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring基础概念"><a href="#Spring基础概念" class="headerlink" title="Spring基础概念"></a>Spring基础概念</h2><h3 id="Spring框架中都用到了哪些设计模式"><a href="#Spring框架中都用到了哪些设计模式" class="headerlink" title="Spring框架中都用到了哪些设计模式"></a>Spring框架中都用到了哪些设计模式</h3><p>Spring框架中使用了大量的设计模式，如下：</p><ul><li>代理模式（Proxy）——在AOP中用的比较多</li><li>单例模式（Singleton）——在Spring配置文件中定义的Bean默认为单例模式</li><li>工厂模式——BeanFactory用来创建对象的实例</li><li>模板方法模式——用来解决代码重复的问题，如RestTemplate、JmsTemplate、JpaTemplate等</li><li>前端控制器——Spring提供了DispatcherServlet来对请求进行分发</li><li>适配器模式——Spring AOP的Advice中使用到了适配器模式，以及Spring MVC中适配Controller时也用到了适配器模式</li><li>观察者模式——Spring事件驱动模型</li><li>装饰者模式——当项目需要连接多个数据库，不同的客户根据需要去访问不同的数据库，装饰者模式可以根据客户的需求动态切换不同的数据源<h2 id="Spring控制反转-IoC"><a href="#Spring控制反转-IoC" class="headerlink" title="Spring控制反转(IoC)"></a>Spring控制反转(IoC)</h2><h3 id="什么是Spring-IoC容器"><a href="#什么是Spring-IoC容器" class="headerlink" title="什么是Spring IoC容器"></a>什么是Spring IoC容器</h3></li></ul><ol><li>简单说就是将创建对象的控制权交给Spring框架。（从程序中剥离）</li><li>IoC是一种思想，主要优点有两个：</li></ol><ul><li>降低代码之间的耦合度</li><li>集中资源统一管理，简化开发</li></ul><ol start="3"><li><p>IoC还有一种说法是DI(Dependency Injection)，即依赖注入。两者更进一步的关系，可以被描述为IoC是一种思想，而DI是IoC的一种实现方式。</p><h3 id="Spring-IoC的实现机制"><a href="#Spring-IoC的实现机制" class="headerlink" title="Spring IoC的实现机制"></a>Spring IoC的实现机制</h3><p>简单来说就是通过解析XML文件获取到对象信息，通过反射获取字节码文件，然后通过字节码文件创建对象，并且在创建对象的过程中使用了工厂模式。</p><h3 id="BeanFactory和ApplicationContext有什么区别"><a href="#BeanFactory和ApplicationContext有什么区别" class="headerlink" title="BeanFactory和ApplicationContext有什么区别"></a>BeanFactory和ApplicationContext有什么区别</h3><p><code>BeanFactory</code>和<code>ApplicationContext</code>是Spring的两大核心接口，都可以当做Spring的容器。它们之间是派生关系，类图如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657444407108-37d950db-1abe-4d12-af32-8ae4c1967775.png#clientId=u48d5a21b-2cf2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=297&id=u15211376&margin=%5Bobject%20Object%5D&name=image.png&originHeight=297&originWidth=1380&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18697&status=done&style=none&taskId=ua62f516f-affe-4e1b-a4c5-fbb2ace0f5c&title=&width=1380" alt="image.png"><br>两者之间的区别有：</p></li><li><p><strong>作用</strong></p></li></ol><p><code>BeanFactory</code>接口作用：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。<br><code>ApplicationContext</code>接作用：<code>ApplicationContext</code>接口作为<code>BeanFactory</code>的派生， 除了提供<code>BeanFactory</code>所具有的功能外，还有额外的功能：</p><ul><li>提供在监听器中注册bean的事件</li><li>载入多个(有继承关系)上下文,使得每一个上下文都专注于一个特定的层次，比如应用的web层</li><li>同时加载多个配置文件</li><li>统一的资源文件访问方式</li><li>继承<code>MessageSource</code>，因此支持国际化</li></ul><ol start="2"><li><strong>加载方式</strong></li></ol><p><code>BeanFactroy</code>：采用的是延迟加载形式来注入Bean，也就是只有在使用到某个bean时，才会对该bean进行加载实例化，这样的弊端很明显，就是如果spring的配置存在问题，那么只有<code>BeanFactory</code>加载后，使用到这个bean时才可以发现问题。<br><code>ApplicationContext</code>：<code>ApplicationContext</code>采用的是预加载机制， 在容器启动时，一次性创建所有的bean。这种可以避免<code>BeanFactory</code>接口中出现的问题，容器启动时就可以发现Spring配置中存在的错误，但缺点是会占用内存空间，并且当配置的bean较多时，程序启动会变慢。</p><ol start="3"><li><strong>创建方式</strong></li></ol><p><code>BeanFactory</code>：采用编程的方式创建，如<code>BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;beans.xml&quot;));</code>。<br><code>ApplicationContext</code>：除了类似<code>BeanFactory</code>采用编程的方式创建外，还可以使用声明的方式创建，在web.xml文件中添加如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--指定Spring配置文件的位置，有多个配置文件时，以逗号分隔--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br><span class="hljs-comment">&lt;!--spring将加载spring目录下的applicationContext.xm1文件--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span><br>    classpath:spring/applicationContext.xml<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><span class="hljs-comment">&lt;!--指定以ContextLoaderLi stener方式启动Spring容器--&gt;</span><br>&lt;1istener&gt;<br>  &lt;1istener-class&gt;<br>    org.springframework.web.context.ContextLoaderListener<br>  &lt;/1istener-class&gt;<br>&lt;/1istener&gt;<br></code></pre></td></tr></table></figure><h3 id="依赖注入的方式"><a href="#依赖注入的方式" class="headerlink" title="依赖注入的方式"></a>依赖注入的方式</h3><ol><li><strong>Set方法注入(Setter Injection)</strong></li></ol><p>Setter方法注入是容器通过调用无参构造器或无参static工厂方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。<br>Setter方法注入也称为属性注入(Field Injection)。</p><ol start="2"><li><strong>构造器注入(Constructor Injection)</strong></li></ol><p>构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p><ol start="3"><li><strong>注解方式</strong></li></ol><p><code>@Autowired</code>默认按类型装配<br><code>@Resource</code>默认按名称装配，当找不到与名称匹配的bean时，才会按类型装配。</p><h3 id="如何选择合适的注入方式"><a href="#如何选择合适的注入方式" class="headerlink" title="如何选择合适的注入方式"></a>如何选择合适的注入方式</h3><p>在实际应用中，没有最好的依赖注入方式，只有最合适的依赖注入方式。<br><strong>选择构造函数注入的理由：</strong></p><ul><li>不需要为每个属性提供Setter方法，减少了类的方法个数</li><li>构造函数可以保证一些重要的属性在Bean实例化时就设置好，避免因为一些重要属性没有提供而导致一个无用Bean实例的情况</li><li>可以更好地封装变量，不需要为每个属性指定Setter的方法，避免外部错误调用</li></ul><p><strong>选择属性注入的理由：</strong></p><ul><li><p>如果类的属性很多，构造函数将会变得非常臃肿，可读性较差</p></li><li><p>构造函数注入不够灵活，如果有些属性是可选的，也需要为可选参数提供null值</p></li><li><p>存在多个构造函数，需要配置文件和构造函数配置歧义问题，配置比较复杂</p></li><li><p>构造函数不利于类的集成和扩展，因为子类需要引用父类复杂的构造函数</p></li><li><p>构造函数注入可能产生<strong>循环依赖问题</strong></p><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="什么是Spring-AOP"><a href="#什么是Spring-AOP" class="headerlink" title="什么是Spring AOP"></a>什么是Spring AOP</h3><p>AOP是Aspect Oriented Programing的简称，中文为面向切面编程。</p><h3 id="AOP解决了什么问题"><a href="#AOP解决了什么问题" class="headerlink" title="AOP解决了什么问题"></a>AOP解决了什么问题</h3><p>在编写代码过程中，经常出现重复的代码，一般情况下会将重复的代码抽象成方法，在需要的地方来调用这个方法，这样就可以减少大量的重复代码。但还是会存在一些问题，比如很多地方都调用了这个方法，突然因业务需求又要删掉，但这个方法已经和业务代码混在了一起， 修改所有调用这个方法的地方也是一个不小的工作量，这种情况就可以用AOP来解决，比如下图中操作数据库的场景：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657532366196-b520333e-bb31-423e-9b2b-95182d306caf.png#clientId=uc8c1e3f3-896e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=849&id=u3a555976&margin=%5Bobject%20Object%5D&name=image.png&originHeight=849&originWidth=984&originalType=binary&ratio=1&rotation=0&showTitle=false&size=237682&status=done&style=none&taskId=u111f3c45-8e7f-4a69-a4c6-8c4a5220842&title=&width=984" alt="image.png"><br>从图片中可以看出，除了执行SQL这部分业务代码，其他都是重复性质的非核心业务代码，AOP的作用就是将这部分非核心代码与核心业务代码分离。<br>Spring AOP是通过<strong>动态代理</strong>来实现的。</p><h3 id="AOP的一些名词"><a href="#AOP的一些名词" class="headerlink" title="AOP的一些名词"></a>AOP的一些名词</h3></li><li><p>连接点(Joinpoint)：连接点可以理解为程序执行的某个特定位置（如：某个方法调用前、调用后，方法抛出异常后）。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。Spring仅支持方法的连接点。</p></li><li><p>切点(Pointcut)：如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。</p><h3 id="Spring-AOP与AspectJ-AOP有什么区别"><a href="#Spring-AOP与AspectJ-AOP有什么区别" class="headerlink" title="Spring AOP与AspectJ AOP有什么区别"></a>Spring AOP与AspectJ AOP有什么区别</h3><table><thead><tr><th><strong>Spring AOP</strong></th><th><strong>AspectJ AOP</strong></th></tr></thead><tbody><tr><td>属于运行时增强</td><td>属于编译时增强</td></tr><tr><td>基于代理</td><td>基于字节码</td></tr><tr><td>仅支持方法级织入</td><td>支持字段、方法、构造函数等织入</td></tr><tr><td>比AspectJ慢</td><td>比Spring AOP快</td></tr><tr><td>简单</td><td>复杂</td></tr></tbody></table></li></ul><h3 id="JDK动态代理和CGLIB动态代理的区别"><a href="#JDK动态代理和CGLIB动态代理的区别" class="headerlink" title="JDK动态代理和CGLIB动态代理的区别"></a>JDK动态代理和CGLIB动态代理的区别</h3><p>JDK动态代理和CGLIB动态代理是Spring AOP中用到两种动态代理方式，如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP ，如果目标对象没有实现接口，则会采用CGLIB动态代理，它们的区别如下：</p><ul><li><p>JDK动态代理是通过反射机制生成一个实现代理接口的匿名类， 在调用具体方法前调InvokeHandler来处理。而CGLIB动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</p></li><li><p>JDK动态代理的核心是实现InvocationHandler接口，使用invoke()方法进行面向切面的处理，调用相应的通知。CGLIB动态代理核心是实现MethodInterceptor接口， 使用intercept()方 法进行面向切面的处理，调用相应的通知。</p></li><li><p>JDK动态代理只能代理实现实现接口的类，不能代理没有实现接口的类。CGLIB动态代理是针对类来实现代理的，对指定的目标类生成一个子类，并覆盖其中方法实现增强，不能对final修饰的类进行代理。</p></li><li><p>在JDK1.6之前，CGLIB动态代理的效率比JDK动态代理要高，JDK1.6开始对JDK动态代理优化后，JDK动态代理的效率比CGLIB动态代理要高，但当大量调用的时候，JDK1.6和JDK 1.7的效率比CGLIB动态代理效率低一些，到JDK1.8，JDK动态代理的效率比CGLIB动态代理高。</p><h2 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h2><h3 id="什么是Spring-Bean"><a href="#什么是Spring-Bean" class="headerlink" title="什么是Spring Bean"></a>什么是Spring Bean</h3><p>Spring Bean是Spring框架在运行时管理的对象，如在XML文件中配置的bean。</p><h3 id="将一个类声明为Spring-Bean的注解有哪些"><a href="#将一个类声明为Spring-Bean的注解有哪些" class="headerlink" title="将一个类声明为Spring Bean的注解有哪些"></a>将一个类声明为Spring Bean的注解有哪些</h3></li><li><p><code>@Component</code>：通用的注解，可标注任意类为Spring组件。如果一个Bean不知道属于哪个层，通常使用此注解。</p></li><li><p><code>@Controller</code>：Spring MVC控制层组件注解。</p></li><li><p><code>@Service</code>：服务层组件注解。</p></li><li><p><code>@Repository</code>：DAO（持久层）组件注解。</p><h3 id="Spring中Bean的作用域-Scope-有哪些"><a href="#Spring中Bean的作用域-Scope-有哪些" class="headerlink" title="Spring中Bean的作用域(Scope)有哪些"></a>Spring中Bean的作用域(Scope)有哪些</h3></li><li><p><strong>singleton</strong>：Spring中的Bean默认都是单例的，也即每个Bean在每个Spring IoC容器中只有一个实例。</p></li><li><p><strong>prototype</strong>：每次请求都会创建一个新的bean实例。</p></li><li><p><strong>request</strong>：每次http请求都会创建一个bean，该作用域仅在基于Web的Spring ApplicationContext情形下有效。</p></li><li><p><strong>session</strong>：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于Web的Spring ApplicationContext情形下有效。</p></li><li><p><strong>global-session</strong>：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于Web的Spring ApplicationContext情形下有效。</p><h3 id="Spring中Bean的生命周期"><a href="#Spring中Bean的生命周期" class="headerlink" title="Spring中Bean的生命周期"></a>Spring中Bean的生命周期</h3><p><a href="https://juejin.cn/post/6844904065457979405">如何记忆 Spring Bean 的生命周期</a></p><h3 id="Spring怎么解决循环依赖问题"><a href="#Spring怎么解决循环依赖问题" class="headerlink" title="Spring怎么解决循环依赖问题"></a>Spring怎么解决循环依赖问题</h3><h4 id="什么是循环依赖问题"><a href="#什么是循环依赖问题" class="headerlink" title="什么是循环依赖问题"></a>什么是循环依赖问题</h4><p>循环依赖是指A依赖于B，B也依赖于A。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">// A中注入B</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> B b;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-comment">// B中注入A</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> A a;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4></li></ul><h2 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h2><h3 id="Spring-Bean相关注解"><a href="#Spring-Bean相关注解" class="headerlink" title="Spring Bean相关注解"></a>Spring Bean相关注解</h3><h4 id="Qualifier注解有什么作用"><a href="#Qualifier注解有什么作用" class="headerlink" title="@Qualifier注解有什么作用"></a>@Qualifier注解有什么作用</h4><p><code>@Qualifier</code>注解一般与<code>@Autowired</code>注解一起使用，作用是当存在多个相同类型的bean时，防止<code>@Autowired</code>注解默认按照byType注入时的混乱问题。在<code>@Qualifier</code>中写上bean的名称即可。</p><h3 id="Web开发相关注解"><a href="#Web开发相关注解" class="headerlink" title="Web开发相关注解"></a>Web开发相关注解</h3><h4 id="Controller注解有什么用"><a href="#Controller注解有什么用" class="headerlink" title="@Controller注解有什么用"></a>@Controller注解有什么用</h4><p><code>@Controller</code>，对应Spring MVC控制层，主要用户接受用户请求并调用Service层返回数据给前端页<br>面。</p><h4 id="ResponseBody注解有什么用"><a href="#ResponseBody注解有什么用" class="headerlink" title="@ResponseBody注解有什么用"></a>@ResponseBody注解有什么用</h4><p><code>@ResponseBody</code>通常和<code>@Controller</code>一起使用，<code>@ResponseBody</code>注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区(响应体中) ,通常用来返回SON数据或者是XML。</p><h3 id="Spring-AOP相关注解"><a href="#Spring-AOP相关注解" class="headerlink" title="Spring AOP相关注解"></a>Spring AOP相关注解</h3><blockquote><p>AOP的注解主要有@Aspect、@Pointcut、@Around、@Before、@After、@AfterReturning、@AfterThrowing。</p></blockquote><ul><li><code>@Aspect</code>，声明一个切面</li><li><code>@Pointcut</code>，增强的切入点</li><li><code>@Before</code>，前置注解，被注解的方法将会在目标方法之前执行</li><li><code>@After</code>，最终注解，被注解的方法将在执行完所有的注解方法后再执行(始终执行)</li><li><code>@Around</code>，环绕注解，被注解的方法将会之前和之后都进行执行</li><li><code>@AfterReturning</code>，后置注解，被注解的方法将会在目标方法执行之后执行(异常不执行)</li><li><code>@AfterThrowing</code>，出现异常后执行<h2 id="Spring事务相关"><a href="#Spring事务相关" class="headerlink" title="Spring事务相关"></a>Spring事务相关</h2><h3 id="Spring事务的传播行为"><a href="#Spring事务的传播行为" class="headerlink" title="Spring事务的传播行为"></a>Spring事务的传播行为</h3>事务的传播行为主要是解决多个方法之间相互调用所产生的事务问题，是Spring框架所提供的事务工具所独有的。<br>用伪代码说明如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方法methodA调用开启事务并设置事务传播行为的methodB，即是事务传播行为问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>    methodB();<br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-meta">@Traction(Propagation = XXX)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>Spring中七种事务传播行为</p><table><thead><tr><th><strong>事务传播行为</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>如果当前没有事务，就新建一个事务；如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>使用当前的事务，如果当前没有事务，就抛出异常。</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>新建事务，如果当前存在事务，把当前事务挂起。</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td></tr></tbody></table><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="什么是Spring-MVC"><a href="#什么是Spring-MVC" class="headerlink" title="什么是Spring MVC"></a>什么是Spring MVC</h3><p>Spring MVC是Spring框架中的一个组件，是其提供的一个基于MVC设计模式的轻量级Web开发框架，本质上相当于Servlet。<br>MVC设计模式，Model View Controller；Model是一个存取数据的对象，View表示模型包含数据的可视化，Controller用于控制数据流向模型对象，并在数据变化时更新视图。</p><h3 id="Spring-MVC的优点"><a href="#Spring-MVC的优点" class="headerlink" title="Spring MVC的优点"></a>Spring MVC的优点</h3><p>它将model、view、controller分离，对web层进行解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。<br>对业务系统各个组件解耦，提高系统的可维护性和扩展性。</p><h3 id="Spring-MVC的工作原理"><a href="#Spring-MVC的工作原理" class="headerlink" title="Spring MVC的工作原理"></a>Spring MVC的工作原理</h3><p>Spring MVC的工作流程图如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658299153930-09bd88a8-81f4-40f9-b922-aa4b82669894.png#clientId=u146ac9cd-79d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=563&id=uffdfa075&margin=%5Bobject%20Object%5D&name=image.png&originHeight=563&originWidth=1164&originalType=binary&ratio=1&rotation=0&showTitle=false&size=260108&status=done&style=none&taskId=u3eba2e6a-e93d-4e18-8e58-21585ea2af5&title=&width=1164" alt="image.png"><br>流程说明如下：<br>(1) 客户端发出一个http请求，web应用服务器接收到这个请求，如果匹配到DispatcherServlet的请求映射路径，web容器会将这个http请求交给DispatcherServlet处理；<br>(2) - (3) DispatcherServlet接收到请求后，根据请求的信息与HandlerMapping的配置找到处理请求的Handler；<br>(4) - (5) DispatcherServlet找到Handler后，通过HandlerAdapter对Handler进行封装，然后再调用Handler；<br>(6) - (7) Handler处理业务逻辑，并返回ModelAndView到DispatcherServlet，ModelAndView包含了视图逻辑名和模型数据信息；<br>(8) - (9) ModelAndView包含的并非真正的视图对象，DispatcherServlet借助ViewResolver完成逻辑视图名到真实视图对象的解析工作；<br>(10) - (11) DispatcherServlet通过真实视图对象View对ModelAndView中的模型数据进行视图渲染；<br>(12) 将渲染的结果返回给客户端。</p><h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><h3 id="Spring-Boot的特点"><a href="#Spring-Boot的特点" class="headerlink" title="Spring Boot的特点"></a>Spring Boot的特点</h3><ul><li>内嵌tomcat和jetty容器，不需要部署war文件到Web容器就可以独立运行应用</li><li>提供许多基于Maven的pom配置模板来简化工程配置</li><li>可以实现自动化配置</li><li>开箱即用，不需要xmI等配置文件<h3 id="Spring-Boot自动配置原理"><a href="#Spring-Boot自动配置原理" class="headerlink" title="Spring Boot自动配置原理"></a>Spring Boot自动配置原理</h3>简单来说就是<code>@SpringBootApplication</code>注解会对jar包下的<strong>spring.factories</strong>文件进行扫描，这个文件中包含了可以进行自动配置的类，当满足<code>@Condition</code>注解指定的条件时，便在依赖的支持下进行实例化，注册到Spring容器中。</li></ul><hr><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h2><h3 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h3><p>Redis是一个高性能的非关系型的键值对数据库。<br>与传统的数据库不同的是Redis存在内存中，所以读写速度非常快，这也是Redis被用作缓存的原因。</p><h3 id="Redis的优缺点"><a href="#Redis的优缺点" class="headerlink" title="Redis的优缺点"></a>Redis的优缺点</h3><p><a href="https://www.yuque.com/poetr/pcno4b/nwyqtq">Redis</a></p><h3 id="Redis为什么用作缓存？相比于Guava有什么优势？"><a href="#Redis为什么用作缓存？相比于Guava有什么优势？" class="headerlink" title="Redis为什么用作缓存？相比于Guava有什么优势？"></a>Redis为什么用作缓存？相比于Guava有什么优势？</h3><p>缓存的定义是访问速度比一般随机存取存储器快的一种高速存储器，而因为Redis是基于内存提供了高性能的数据存取功能，其比较显著的优势就是非常地快。<br>缓存可以分为本地缓存或者分布式缓存，比较常用的guava缓存就是一种本地缓存，其主要特点是轻量并且快速，生命周期随着JVM的销毁而结束，缺点是在多实例的情况下，每个实例都要自己保存一份缓存，这样会导致缓存的一致性出现问题。<br>Redis则是分布式缓存，在多实例情况下，每个实例都共享一份缓存数据， 缓存具备一致性。 缺点是要保持Redis的高可用整体架构会比较复杂。</p><h3 id="Redis-6-0之后为什么引入了多线程"><a href="#Redis-6-0之后为什么引入了多线程" class="headerlink" title="Redis 6.0之后为什么引入了多线程"></a>Redis 6.0之后为什么引入了多线程</h3><p>前面也说了Redis的瓶颈在内存和网络，Redis6.0引入多线程主要是为了解决网路IO读写这个瓶颈，执行命令还是单线程执行的，所以也不存在线程安全问题。<br>Redis6.0默认是否开启了多线程呢?<br>默认是没有开启的，如需开启，需要修改配置文件redis.conf: io-threads-do-reads no，no改为yes。</p><h3 id="Redis的数据类型有哪些"><a href="#Redis的数据类型有哪些" class="headerlink" title="Redis的数据类型有哪些"></a>Redis的数据类型有哪些</h3><p>Redis常见的数据类型有<strong>五种</strong>，即<strong>String、Hash、Set、List和ZSet。</strong></p><table><thead><tr><th>数据类型</th><th>可以存储的值</th><th>操作</th><th>应用场景</th></tr></thead><tbody><tr><td>String</td><td>字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作；</td><td></td></tr><tr><td>对整数和浮点数执行自增或者自减操作。</td><td>键值对缓存及常规计数；</td><td></td><td></td></tr><tr><td>微博数、粉丝数</td><td></td><td></td><td></td></tr><tr><td>List</td><td>列表（内部使用双向链表实现）</td><td>从两端压入或者弹出元素；</td><td></td></tr><tr><td>对单个或者多个元素进行修剪，只保留一个范围内的元素。</td><td>存储文章ID列表、存储评论列表等</td><td></td><td></td></tr><tr><td>Set</td><td>无序集合（内部使用值为空的散列表）</td><td>添加、获取、移除单个元素；</td><td></td></tr><tr><td>检查一个元素是否存在于集合中；</td><td></td><td></td><td></td></tr><tr><td>计算交集、并集、差集；</td><td></td><td></td><td></td></tr><tr><td>从集合里面随机获取元素。</td><td>共同好友、共同关注等</td><td></td><td></td></tr><tr><td>ZSet</td><td>有序集合（内部使用散列表和跳表）</td><td>添加、获取、删除元素；</td><td></td></tr><tr><td>根据分值范围或者成员来获取元素；</td><td></td><td></td><td></td></tr><tr><td>计算一个键的排名。</td><td>去重、获取排名前几的用户</td><td></td><td></td></tr><tr><td>Hash</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对；</td><td></td></tr><tr><td>获取所有键值对；</td><td></td><td></td><td></td></tr><tr><td>检查某个键是否存在。</td><td>常用于存储对象</td><td></td><td></td></tr></tbody></table><h3 id="Redis的数据结构有哪些"><a href="#Redis的数据结构有哪些" class="headerlink" title="Redis的数据结构有哪些"></a>Redis的数据结构有哪些</h3><p>Redis的数据结构有<strong>简单动态字符串（SDS）、链表、字典、跳跃表、整数集合、压缩列表等。</strong></p><ul><li><strong>链表</strong>：链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。链表是列表的底层实现之一。</li><li><strong>字典</strong>：又称为符号表(symbol table)、关联数组(associativearray) 或映射(map) ，是一种用于保存键值对(key-value pair)的抽象数据结构。字典在Redis中的应用相当广泛，比如Redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。</li><li><strong>整数集合</strong>：整数集合(intset) 是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。|</li><li>**压缩列表(ziplist)**：压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型(sequential) 数据结构。</li><li><strong>跳跃表（skiplist）</strong>：跳跃表是一种有序数据结构，它通过在每个节点维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表支持平均O(logN)，最坏O(N)时间复杂度的节点查找，还可以通过顺序性操作来批量处理节点。跳跃表是有序集合键的底层实现之一。</li></ul><p>跳跃表本质上采用的是一种<strong>空间换时间的策略</strong>， 是一种可以可以进行二分查找的有序链表，跳表在原有的有序链表上增加了多级索引，通过索引来实现快速查询。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。</p><h3 id="Redis的应用场景有哪些"><a href="#Redis的应用场景有哪些" class="headerlink" title="Redis的应用场景有哪些"></a>Redis的应用场景有哪些</h3><ul><li>缓存：Redis基于内存，读写速度非常快，并且有键过期功能和键淘汰策略，可以作为缓存使用。</li><li>排行榜：Redis提供的有序集合可以很方便地实现排行榜。</li><li>分布式锁：Redis的setnx功能来实现分布式的锁。</li><li>社交功能：实现共同好友、共同关注等。</li><li>计数器：通过String进行自增自减实现计数功能。</li><li>消息队列：Redis提供了发布、订阅、阻塞队列等功能，可以实现一个简单的消息队列。</li></ul><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="MyBatis与Hibernate比较"><a href="#MyBatis与Hibernate比较" class="headerlink" title="MyBatis与Hibernate比较"></a>MyBatis与Hibernate比较</h2><p><strong>相同点</strong></p><ul><li>MyBatis和Hibernate都是ORM（对象关系映射）框架，是对JDBC的封装；</li></ul><p><strong>不同点</strong></p><ul><li><p>从ORM：MyBatis是半ORM，Hibernate是完全ORM；MyBatis是一个半自动映射的框架，配置Java对象与sq|语句执行结果的对应关系，多表关联关系配置简单；Hibernate是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂。</p></li><li><p>MyBatis相比Hibernate更加轻量，启动速度更快</p></li><li><p>从SQL优化和移植性：Hibernate对SQL语句封装，提供了日志、缓存、级联(级联比MyBatis强大)等特性，此外还提供HQL(Hibernate Query Language)操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。MyBatis需要手动编写SQL，支持动态SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sq|语句优化容易。</p></li><li><p>从开发难度和学习成本：Hibernate是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如办公自动化系统；MyBatis是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如互联网电子商务系统。</p></li><li><p>总结：MyBatis是一个小巧、方便、高效、简单、直接、半自动的持久层框架；Hibernate是一个强大、方便、高效、复杂、间接、全自动的持久层框架。</p><h2 id="为什么说MyBatis是半自动ORM映射工具"><a href="#为什么说MyBatis是半自动ORM映射工具" class="headerlink" title="为什么说MyBatis是半自动ORM映射工具"></a>为什么说MyBatis是半自动ORM映射工具</h2><p>Hibernate属于全⾃动ORM映射⼯具，使⽤Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而MyBatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射⼯具。</p><h2 id="MyBatis框架适用场景"><a href="#MyBatis框架适用场景" class="headerlink" title="MyBatis框架适用场景"></a>MyBatis框架适用场景</h2></li><li><p>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案；</p></li><li><p>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。</p><h2 id="MyBatis都有哪些Executor执行器"><a href="#MyBatis都有哪些Executor执行器" class="headerlink" title="MyBatis都有哪些Executor执行器"></a>MyBatis都有哪些Executor执行器</h2><p>Mybatis有三种基本的Executor执⾏器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p><h2 id="MyBatis是否支持延迟加载"><a href="#MyBatis是否支持延迟加载" class="headerlink" title="MyBatis是否支持延迟加载"></a>MyBatis是否支持延迟加载</h2><p>MyBatis仅⽀持association关联对象和collection关联集合对象的延迟加载，association指的就是⼀对⼀，collection指的就是⼀对多查询。在MyBatis配置⽂件中，可以配置是否启⽤延迟加载<code>lazyLoadingEnabled=true|false</code>。<br>它的原理是，使⽤CGLIB创建⽬标对象的代理对象，当调⽤⽬标⽅法时，进⼊拦截器⽅法，比如调⽤<code>a.getB().getName()</code>，拦截器invoke()⽅法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调⽤a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()⽅法的调⽤。这就是延迟加载的基本原理。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>面试题库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库分库分表</title>
    <link href="/2022/07/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <url>/2022/07/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在常用的数据库优化方法中，分库分表是最有效的方法之一。本文简单介绍有关数据库分库分表的知识点。</p><h2 id="什么是分库分表"><a href="#什么是分库分表" class="headerlink" title="什么是分库分表"></a>什么是分库分表</h2><p>所谓分库分表，就是将数据库分割成几部分，或者把数据库中的表分割成几部分。</p><h2 id="为什么需要分库分表"><a href="#为什么需要分库分表" class="headerlink" title="为什么需要分库分表"></a>为什么需要分库分表</h2><p>因为随着企业业务的快速增加，数据库中的数据量会猛增，这样一来会严重影响访问性能，给用户带来不好的用户体验，甚至导致系统奔溃。所以优化迫在眉睫，采用分库分表就是一种很有用的方式。</p><h2 id="怎样分库分表"><a href="#怎样分库分表" class="headerlink" title="怎样分库分表"></a>怎样分库分表</h2><p>分库分表按照对库或表的拆分方向性，可以分为<strong>水平</strong>和<strong>垂直</strong>。其中，<strong>水平是将数据进行切割</strong>，而<strong>垂直是将结构进行切割</strong>。即分库分表有<strong>水平分库</strong>、<strong>水平分表</strong>、<strong>垂直分库</strong>和<strong>垂直分表</strong>。</p><h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p>如系统中有用户数据库，可以根据用户的id将用户信息存储到不同的数据库中，如下图所示。</p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/%E6%B0%B4%E5%B9%B3%E5%88%86%E5%BA%93.png" class="" title="水平分库"><p>即水平分库就是以字段为依据，按照一定的策略（Hash、range等）将一个库中的数据拆分到多个库中。</p><p>拆分后，理想的结果是：</p><ul><li>每个库的结构都一样；</li><li>每个库的数据都不一样，没有交集；</li><li>所有库的并集是全量数据。</li></ul><h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p>依然举个例子，某系统中某个库存在用户表，则可以将数据切割成多份，存储到不同表中，如下图所示。</p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8.png" class="" title="水平分表"><p>所以水平分表就是将一张表的数据切割成n份，策略与水平分库类似。</p><p>理想情况下，水平分表的结果是：</p><ul><li>每个表的结构都一样；</li><li>每个表的数据都不一样；</li><li>所有表的并集是全量数据。</li></ul><h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>垂直分库是将不同的表拆分到不同的库中。如下图所示。</p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93.png" class="" title="垂直分库"><p>理想情况下，垂直分库的结果是：</p><ul><li>每个库的结构（表）不一样；</li><li>每个库的数据也不一样，没有交集；</li><li>所有库的并集是全量数据。</li></ul><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>垂直分表是将原本一张表按照字段活跃性等指标拆分成不同的表。如下图所示。</p><img src="/2022/07/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8.png" class="" title="垂直分表"><p>理想情况下，垂直分表的结果是：</p><ul><li>每个表的结构都不一样；</li><li>每个表的数据也不一样，但不同表存在一列交集，即主键，用于关联数据；</li><li>所有表的并集是全量数据。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Activiti</title>
    <link href="/2022/07/13/Activiti/"/>
    <url>/2022/07/13/Activiti/</url>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在实际社会生产环境中，我们存在这样的需要，即需要由一个人发起一项活动，这个活动涉及到多个参与者，且可能位于不同的空间中。这样的一个活动就是流程，比如我们常见的请假过程，就是一个流程：由请假人发起请假（填写请假表单），之后由部门领导或老师审批，一直到最终部门审批。</p><p>为了更加方便的处理上述过程（自动化处理），流程支持工具出现了，比如我们这里主要介绍的<code>Activiti</code>。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>流程自动化的传统做法是给条目加上状态字段，每个角色读取属于自己状态码所对应的条目信息然后进行操作并改变状态码信息。这样带来的问题是，当业务流程发生改变时，代码需要重写。<code>Activiti</code>的出现就是为了解决上述问题。</li></ul><ul><li>在流程定义中，工作流需要规范定义节点（绘制流程图时），如某个节点拥有哪些属性、使用什么图标等，这一套规则依赖于<code>bpmn</code>。</li></ul><ul><li><p>流程支持工具总的步骤是：</p><ul><li>先将业务流程图画好（专门的工具【<code>Activiti</code>中是<code>Activiti Designer</code>】）</li><li>将流程图中每个节点的数据读取并放入表中</li><li>读取表中的第一条记录，处理并删除</li></ul></li><li><p>原理总结：</p><ul><li>业务流程图要规范化，要遵守一套标准</li><li>这个业务流程图实际上是一个<code>xml</code>文件</li><li>读取业务流程图的过程就是解析<code>xml</code>文件的过程</li><li>读取流程图中的一个节点相当于解析一个<code>xml</code>节点，并将数据插入到<code>mysql</code>表中，形成一条记录</li><li>主要将所有节点都读取并存入<code>mysql</code>表中</li><li>后面只需要读取<code>mysql</code>中的记录</li><li>业务流程的推进，后面即转换为读取表中数据并处理</li></ul></li></ul><ul><li><p><code>Activiti</code>软件本身关联到的技术：<code>xml</code>+<code>dom4j</code>+<code>mysql</code>+<code>jdbc</code></p><ul><li>流程定义文件<code>BPMN</code>实际上是一个<code>XML</code>文件，需要用到解析工具</li><li>自动生成表时需要与数据库交互</li></ul></li><li><p>一些术语的全称</p><ul><li><code>BPM(Business Process Management)</code> 业务流程管理</li><li><code>BPMN(Business Process Model And Notation)</code> 业务流程模型和符号</li><li><code>BPMI(Business Process Management Initiative)</code> </li></ul></li></ul><h2 id="使用Activiti"><a href="#使用Activiti" class="headerlink" title="使用Activiti"></a>使用Activiti</h2><ul><li>需要将<code>Activiti</code>整合到项目中</li><li>实现业务流程建模，即使用<code>BPMN</code>实现业务流程图</li><li>部署业务流程到<code>Activiti</code><ul><li>流程定义部署是指将线下定义的流程（用建模工具<code>BPMN</code>绘制的流程图和生成的<code>png</code>流程图片）通过调用<code>activiti</code>中的相关<code>API</code>部署到<code>activiti</code>数据库中。</li></ul></li><li>启动流程实例</li><li>查询待办任务</li><li>处理待办任务</li><li>结束流程</li></ul><ul><li>针对<code>Eclipse</code>和<code>IDEA</code>有不同的插件整合方式（目的是让集成开发环境支持<code>Activiti</code>开发）</li></ul><ul><li><p>在开发前，需要导入相应的<code>jar</code>包，一般使用<code>Maven</code>构建项目，故在<code>pom.xml</code>文件中写入依赖的坐标即可（参照项目中的<code>actiProj</code>项目文件）</p></li><li><p>引入依赖并配置好数据库等之后，执行测试代码，会生成25张表（视<code>Activiti</code>版本不同而不同，这里使用的<code>Activiti</code>版本是<code>7.0.0.Beta1</code>）</p></li><li><p>25张表的名称有一定的规律</p><img src="/2022/07/13/Activiti/image-20210505110141039.png" class="" title="Activiti生成的数据库表"><ul><li>均以<code>act</code>开头</li><li>第二部分是表示表的用途的字符标识（<strong>用途和流程服务的API对应</strong>）<ul><li><code>act_re_*</code> : ‘re’表示’<strong>repository</strong>‘；这些表包含了静态信息，如<strong>流程定义</strong>和<strong>流程资源</strong>（图片、规则等）【共3张】；<code>RepositoryService</code>接口所操作的表。</li><li><code>act_ru_*</code> : ‘ru’表示’<strong>runtime</strong>‘；这些表是运行时的表（<code>RuntimeService</code>接口所控制），包含流程实例、任务、变量、异步任务等运行中的数据（只在流程实例运行过程中保存这些数据，流程结束时会删除这些数据，兼顾表的大小和速度）【共10张】。</li><li><code>act_hi_*</code> : ‘hi’表示’history’；这些表包含历史数据，比如历史流程实例、变量、任务等【共8张】。</li><li><code>act_ge_*</code> : ‘ge’表示’general’；这些表包含通用数据，用于不同场景下【共2张】。</li><li><code>act_evt_log</code> : 该表包含日志信息。</li><li><code>act_procdef_info</code> : 该表包含流程定义信息。</li></ul></li></ul></li></ul><h2 id="Activiti服务架构图"><a href="#Activiti服务架构图" class="headerlink" title="Activiti服务架构图"></a>Activiti服务架构图</h2><img src="/2022/07/13/Activiti/20191226173208831.png" class="" title="Activiti服务架构图"><h3 id="流程引擎配置文件"><a href="#流程引擎配置文件" class="headerlink" title="流程引擎配置文件"></a>流程引擎配置文件</h3><p><code>activiti.cfg.xml</code>是<code>Activiti</code>默认的配置文件，该配置文件类似于<code>Spring</code>的配置文件，在其中主要配置数据源、事务以及<code>Activiti</code>的配置，如<code>ProcessEngineConfiguration</code>的配置。下面的事例是一个基本的流程配置文件，定义了数据源和流程引擎。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/beans </span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/context </span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/tx </span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/tx/spring-tx.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/aop </span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/activiti&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;password&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 使用脱机方式创建对象 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 设置是否自动生成数据表 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;databaseSchemaUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="ProcessEngineConfiguration"><a href="#ProcessEngineConfiguration" class="headerlink" title="ProcessEngineConfiguration"></a>ProcessEngineConfiguration</h3><ul><li>流程引擎的配置类；</li><li>位于<code>org.activiti.engine</code>包中；</li><li>通过该类的对象可以创建工作流引擎<code>ProcessEngine</code>。</li></ul><ul><li><p>创建工作流引擎（<code>ProcessEngineConfiguration</code>）通常有两种形式：</p><ul><li><p>形式一：使用脱机方式创建（不与<code>Spring</code>整合）</p><ul><li><p>使用的类：<code>StandaloneProcessEngineConfiguration</code>（在<code>org.activiti.engine.impl.cfg</code>包中）（如上面的配置文件中就是使用该类创建）</p></li><li><p>通常<code>Activiti</code>可以单独运行，通过这种方式创建的<code>ProcessEngine</code>，事务由<code>Activiti</code>自己处理。</p></li><li><p>使用这种方式的配置文件如下，名称通常固定为<code>activiti.cfg.xml</code>，同时<code>bean</code>名称也固定，可以从<code>ProcessEngineConfiguration</code>的源代码中看出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ProcessEngineConfiguration <span class="hljs-title function_">createProcessEngineConfigurationFromResourceDefault</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> createProcessEngineConfigurationFromResource(<span class="hljs-string">&quot;activiti.cfg.xml&quot;</span>, <span class="hljs-string">&quot;processEngineConfiguration&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ProcessEngineConfiguration <span class="hljs-title function_">createProcessEngineConfigurationFromResource</span><span class="hljs-params">(String resource)</span> &#123;<br>    <span class="hljs-keyword">return</span> createProcessEngineConfigurationFromResource(resource, <span class="hljs-string">&quot;processEngineConfiguration&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ProcessEngineConfiguration <span class="hljs-title function_">createProcessEngineConfigurationFromResource</span><span class="hljs-params">(String resource, String beanName)</span> &#123;<br>    <span class="hljs-keyword">return</span> BeansConfigurationHelper.parseProcessEngineConfigurationFromResource(resource, beanName);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/activiti&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;password&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 使用脱机方式创建对象 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 设置是否自动生成数据表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;databaseSchemaUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>注意：虽然形式一事务由<code>Activiti</code>自己处理，但同时使用到了<code>Spring</code>的依赖注入来创建实例。</p></li></ul></li></ul><ul><li>形式二：通过与<code>Spring</code>整合的方式<ul><li>使用的类：<code>SpringProcessEngineConfiguration</code>（在<code>org.activiti.spring</code>包中）</li><li>使用整合的方式创建时，配置文件需要是与<code>Spring</code>整合的配置文件，名称通常是<code>activiti-spring.cfg.xml</code>。但事实上上面形式一的配置文件就可以，只不过需要改变里面<code>bean</code>实例的相关配置。</li></ul></li></ul></li></ul><ul><li><p>创建<code>processEngineConfiguration</code></p><ul><li><p>在业务类中可以通过下面的代码创建<code>processEngineConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ProcessEngineConfiguration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(<span class="hljs-string">&quot;activiti.cfg.xml&quot;</span>); <span class="hljs-comment">// 参数为activiti配置文件名称，通常在类路径下</span><br></code></pre></td></tr></table></figure></li><li><p>通过上面代码创建<code>processEngineConfiguration</code>时，需要在配置文件中存在一个名称为<code>processEngineConfiguration</code>的<code>bean</code>，如果不想使用默认的<code>bean</code>名称，可以使用之前源码中的第三块代码，其中的<code>beanName</code>在配置文件中和调用方法中需要保持一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ProcessEngineConfiguration <span class="hljs-title function_">createProcessEngineConfigurationFromResource</span><span class="hljs-params">(String resource, String beanName)</span> &#123;<br>    <span class="hljs-keyword">return</span> BeansConfigurationHelper.parseProcessEngineConfigurationFromResource(resource, beanName);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="ProcessEngine"><a href="#ProcessEngine" class="headerlink" title="ProcessEngine"></a>ProcessEngine</h3><ul><li><code>ProcessEngine</code>的存在跟它的名称一样，是一个引擎，只有存在这个引擎，才能使用这个引擎所在系统的各种服务，即其本质上是一个门面接口。</li><li>在<code>ProcessEngine</code>对象中，提供了调用各种服务的方法，这些服务有<code>RepositoryService</code>, <code>RuntimeService</code>, <code>TaskService</code>, <code>HistoryService</code>, <code>ManagementService</code>, <code>DynamicBpmnService</code>。与上面的架构图相比，<code>Activiti7</code>中去掉了<code>IdentityService</code>和<code>FormService</code>两个服务。</li><li>获取到相应的服务后，实质上就可以操作生成的对应的数据表（如<code>HistoryService</code>服务就可以操作与流程历史数据相关的表<code>act_hi_*</code>）。</li></ul><ul><li><p>创建方式：</p><ul><li><p>一般方式：通过<code>ProcessEngineConfiguration</code>创建，上面<code>ProcessEngineConfiguration</code>章节中就是使用这种方式创建的。通过这种方式创建时，灵活性更高，程序员有更多的选择性。</p></li><li><p>简单方式：通过<code>ProcessEngines</code>创建，这种创建方式通常需要满足以下两个条件：① <code>Activiti</code>的配置文件名称为<code>activiti.cfg.xml</code>；②在配置文件中存在一个id为<code>processEngineConfiguration</code>的<code>bean</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ProcessEngine</span> <span class="hljs-variable">processEngine</span> <span class="hljs-operator">=</span> ProcessEngines.getDefaultProcessEngine();<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Service（各种服务）的创建"><a href="#Service（各种服务）的创建" class="headerlink" title="Service（各种服务）的创建"></a>Service（各种服务）的创建</h3><p>在架构图中的末端，是一些具体的<code>Service API</code>，如何创建这些服务的对象呢？</p><p>如前面所述，<code>ProcessEngine</code>是一个引擎，提供调用各种服务接口的方法，故当然可以通过<code>ProcessEngine</code>创建这些<code>Service</code>对象。</p><ul><li><p><code>Service</code>是工作流引擎提供用于进行工作流部署、执行、管理的服务接口。具体如下：</p><table><thead><tr><th align="center">服务接口</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">RepositoryService</td><td align="center"><code>Activiti</code>的资源管理类</td></tr><tr><td align="center">RuntimeService</td><td align="center"><code>Activiti</code>的流程运行管理类</td></tr><tr><td align="center">TaskService</td><td align="center"><code>Activiti</code>的任务管理类</td></tr><tr><td align="center">HistoryService</td><td align="center"><code>Activiti</code>的历史管理类</td></tr><tr><td align="center">ManagementService</td><td align="center"><code>Activiti</code>的引擎管理类</td></tr></tbody></table></li></ul><ul><li><p>通过<code>ProcessEngine</code>创建各种<code>Service</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RepositoryService</span> <span class="hljs-variable">repositoryService</span> <span class="hljs-operator">=</span> processEngine.getRepositoryService();<br><span class="hljs-type">RuntimeService</span> <span class="hljs-variable">runtimeService</span> <span class="hljs-operator">=</span> processEngine.getRuntimeService();<br><span class="hljs-type">DynamicBpmnService</span> <span class="hljs-variable">dynamicBpmnService</span> <span class="hljs-operator">=</span> processEngine.getDynamicBpmnService();<br></code></pre></td></tr></table></figure></li><li><p><code>ProcessEngine</code>中提供的调用各种<code>Service</code>的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">RepositoryService <span class="hljs-title function_">getRepositoryService</span><span class="hljs-params">()</span>;<br><br>RuntimeService <span class="hljs-title function_">getRuntimeService</span><span class="hljs-params">()</span>;<br><br>TaskService <span class="hljs-title function_">getTaskService</span><span class="hljs-params">()</span>;<br><br>HistoryService <span class="hljs-title function_">getHistoryService</span><span class="hljs-params">()</span>;<br><br>ManagementService <span class="hljs-title function_">getManagementService</span><span class="hljs-params">()</span>;<br><br>DynamicBpmnService <span class="hljs-title function_">getDynamicBpmnService</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="详述各种Service"><a href="#详述各种Service" class="headerlink" title="详述各种Service"></a>详述各种Service</h3><h4 id="RepositoryService"><a href="#RepositoryService" class="headerlink" title="RepositoryService"></a>RepositoryService</h4><ul><li><code>RepositoryService</code>是<code>Activiti</code>中的资源管理类（管理Activiti内建的Repository），提供了管理和控制流程发布包和流程定义的操作（对Repository的存取服务）。具体如下：<ul><li>使用<strong>工作流建模工具</strong>设计的业务流程图需要借助该服务将流程定义文件的内容部署到计算机；</li><li>查询引擎中的流程发布包和流程定义；</li><li>暂停或激活流程发布包，分别对应全部和特定流程定义；</li><li>获得多种资源，如包含在发布包里的文件，引擎自动生成的流程图；</li><li>获得流程定义的<code>POJO</code>版本，从而实现<code>Java</code>解析，而非<code>XML</code>解析。</li></ul></li></ul><h4 id="RuntimeService"><a href="#RuntimeService" class="headerlink" title="RuntimeService"></a>RuntimeService</h4><ul><li>是<code>Activiti</code>的流程运行管理类，可以获取很多<strong>流程执行</strong>相关的信息。</li><li>在<code>Activiti</code>中，每当一个流程定义被启动一次之后，都会生成一个相应的流程对象实例。Runtime Service提供了启动流程、查询流程实例、设置获取流程实例变量等功能。此外它还提供了对流程部署、流程定义和流程实例的存取服务。</li></ul><h4 id="TaskService"><a href="#TaskService" class="headerlink" title="TaskService"></a>TaskService</h4><ul><li>是<code>Activiti</code>的任务管理类，可以获取到<strong>任务</strong>的信息。</li><li>在<code>Activiti</code>中业务流程定义中的每一个执行节点被称为一个Task，对流程中的数据存取、状态变更等操作均需要在Task中完成。Task Service提供了对用户Task和Form相关的操作。它提供了运行时任务查询、领取、完成、删除以及变量设置等功能。</li></ul><h4 id="HistoryService"><a href="#HistoryService" class="headerlink" title="HistoryService"></a>HistoryService</h4><ul><li>是<code>Activiti</code>的历史管理类，可以查询到<strong>流程的历史信息</strong>。在执行流程时，引擎会保存诸如流程实例启动时间、任务参与者、完成任务的时间、每个流程实例的执行路径等数据（根据配置确定），这些数据可以通过该服务查询获得。</li><li>History Service用于获取正在运行或已经完成的流程实例的信息，与Runtime Service中获取的流程信息不同，历史信息包含已经持久化存储的永久信息，并已经被针对查询优化。</li></ul><h4 id="ManagementService"><a href="#ManagementService" class="headerlink" title="ManagementService"></a>ManagementService</h4><ul><li>是<code>Activiti</code>的引擎管理类，提供对<code>Activiti</code>流程引擎的管理和维护功能，这些功能不在工作流驱动的应用程序中使用，主要用于<code>Activiti</code>系统的日常维护。</li></ul><h4 id="IdentityService"><a href="#IdentityService" class="headerlink" title="IdentityService"></a>IdentityService</h4><ul><li><code>Activiti</code>中内置了用户以及组管理的功能，必须使用这些用户和组的信息才能获取到相应的Task。Identity Service提供了对<code>Activiti</code>系统中的用户和组的管理功能。</li></ul><h4 id="FormService"><a href="#FormService" class="headerlink" title="FormService"></a>FormService</h4><ul><li><code>Activiti中</code>的流程和状态Task均可以关联业务相关的数据。通过使用Form Service可以存取启动和完成任务所需的表单数据并且根据需要来渲染表单。</li></ul><h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h2><p>要使用<code>Activiti</code>处理流程业务，在上述理论部分也提到，首先需要为你的开发环境提供支持开发的各种插件，具体见上面的内容。</p><p>在做好准备工作之后，就可以开始项目的开发了。</p><h3 id="（1）流程定义"><a href="#（1）流程定义" class="headerlink" title="（1）流程定义"></a><strong>（1）流程定义</strong></h3><ul><li><p>在流程的定义中，需要使用到<code>Activiti-Designer</code>工具，该工具提供绘制流程图的画板（Palette），在画板中包括下面的结点：</p><ul><li><p><code>Connection</code>：连接</p></li><li><p><code>Event</code>：事件</p></li><li><p><code>Task</code>：任务</p></li><li><p><code>Gateway</code>：网关</p></li><li><p><code>Container</code>：容器</p></li><li><p><code>Boundary event</code>：边界事件</p></li><li><p><code>Intermediate event</code>：中间事件</p><img src="/2022/07/13/Activiti/image-20210505170416917.png" class="" title="Designer提供的面板"></li></ul></li></ul><ul><li><p>需要注意的是，在定义流程的过程中，还需要为目标流程设置一些属性（如流程的ID、流程的名称等），具体界面视集成开发环境的不同而不同。在笔者使用的Eclipse集成开发环境中，需要在<code>Properties</code>视图中进行配置，具体打开该视图的步骤是：单击工具栏中的<code>Window</code>——&gt;选中<code>Show View</code>选项——&gt;点击<code>Other</code>子选项——&gt;在弹出的对话框中搜索<code>Properties</code>并选中回车即可。</p><ul><li>设置整个流程的属性（单击空白部分，即可在<code>Properties</code>视图窗口中显示流程的相关属性），主要设置流程的ID和名称</li></ul><img src="/2022/07/13/Activiti/image-20210505165922569.png" class="" title="设置属性"><ul><li><p>设置各个结点的属性（单击流程图中目标结点，在<code>Properties</code>视图窗口中显示相关属性），只要设置结点的任务审批人</p><img src="/2022/07/13/Activiti/image-20210505171520863.png" class="" title="设置结点属性"></li></ul></li></ul><ul><li><p>在绘制并配置好流程图（定义好流程）之后，会生成<code>.bpmn</code>格式的文件。</p><img src="/2022/07/13/Activiti/image-20210505171720055.png" class="" title="生成的BPMN格式的文件"></li></ul><h3 id="（2）部署流程定义"><a href="#（2）部署流程定义" class="headerlink" title="（2）部署流程定义"></a><strong>（2）部署流程定义</strong></h3><ul><li><p>有了流程图（流程定义）还不行，需要将其部署到工作流引擎<code>activiti</code>中。方法如下：</p><ul><li><p>使用<code>ProcessEngine</code>创建<code>RepositoryService</code>；</p></li><li><p>使用<code>repositoryService</code>部署已经定义好的流程。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建ProcessEngine</span><br><span class="hljs-type">ProcessEngine</span> <span class="hljs-variable">processEngine</span> <span class="hljs-operator">=</span> ProcessEngines.getDefaultProcessEngine();<br><br><span class="hljs-comment">// 得到RepositoryService实例</span><br><span class="hljs-type">RepositoryService</span> <span class="hljs-variable">repositoryService</span> <span class="hljs-operator">=</span> processEngine.getRepositoryService();<br><br><span class="hljs-comment">// 进行部署</span><br><span class="hljs-comment">// 方式一：单个文件分别部署</span><br><span class="hljs-type">Deployment</span> <span class="hljs-variable">deployment</span> <span class="hljs-operator">=</span> repositoryService.createDeployment()<br>    .addClasspathResource(<span class="hljs-string">&quot;diagram/holiday.bpmn&quot;</span>) <span class="hljs-comment">// bpmn文件</span><br>    .addClasspathResource(<span class="hljs-string">&quot;diagram/holiday.png&quot;</span>) <span class="hljs-comment">// 图片文件</span><br>    .name(<span class="hljs-string">&quot;请假流程&quot;</span>)<br>    .deploy(); <span class="hljs-comment">// 部署</span><br><br><span class="hljs-comment">// 方式二：压缩包部署方式(将单个流程定义文件添加到压缩包之后部署)（这种方式便于以后实际的服务器部署）</span><br>ActivitiDeployment.class.getClass().getClassLoader();<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> ClassLoader.getSystemResourceAsStream(<span class="hljs-string">&quot;diagram/holidayBPMN.zip&quot;</span>);<br><span class="hljs-type">ZipInputStream</span> <span class="hljs-variable">zipInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZipInputStream</span>(is);<br><br><span class="hljs-comment">// 进行部署</span><br><span class="hljs-type">Deployment</span> <span class="hljs-variable">deployment</span> <span class="hljs-operator">=</span> repositoryService.createDeployment()<br>    .addZipInputStream(zipInputStream)<br>    .name(<span class="hljs-string">&quot;请假流程&quot;</span>).deploy();<br><br><span class="hljs-comment">// 输出部署信息</span><br>System.out.println(deployment.getName()); <span class="hljs-comment">// 请假流程</span><br>System.out.println(deployment.getId()); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li><li><p>可以发现，在输出的部署信息中，名称与我们设置的流程名称一致，而流程的ID是“1”，这是因为使用了<code>MySQL</code>的主键自动增长策略，观察被操作的数据库表<code>act_re_deployment</code>表可以得知。</p><img src="/2022/07/13/Activiti/image-20210505175126201.png" class="" title="act_re_deployment表变化"></li></ul></li></ul><ul><li><p>涉及到的表</p><ul><li><p><code>act_re_deployment</code>：部署信息（如不是流程的名称、部署时间等）</p></li><li><p><code>act_re_procdef</code>：流程定义的一些信息（如流程的key等）</p><img src="/2022/07/13/Activiti/image-20210505181500549.png" class="" title="act_re_procdef表变化一"><img src="/2022/07/13/Activiti/image-20210505181526481.png" class="" title="act_re_procdef表变化二"></li><li><p><code>act_ge_bytearray</code>：流程定义的<code>bpmn</code>文件和<code>png</code>文件</p><img src="/2022/07/13/Activiti/image-20210505181625081.png" class="" title="act_ge_bytearray表变化"></li></ul></li></ul><h3 id="（3）启动一个流程实例"><a href="#（3）启动一个流程实例" class="headerlink" title="（3）启动一个流程实例"></a><strong>（3）启动一个流程实例</strong></h3><ul><li><p>流程定义部署到<code>activiti</code>中后，就可以通过工作流管理业务流程了。这种关系类似<code>Java中</code>的<code>Java类</code>和对象，光有类不行，还需要通过实例化一个类对象才能使用该类的所有属性和方法。</p></li><li><p>启动一个流程，在该实例中就是发起一个新的请假申请单。发起人（张三）发起一个请假申请单，需要启动一个流程实例；请假申请单发起一个请假单也需要启动一个流程实例。</p></li><li><p>启动方法如下：</p><ul><li><p>使用<code>ProcessEngine</code>创建<code>RuntimeService</code>对象实例；</p></li><li><p>使用<code>RuntimeServcie</code>实例对象根据已经定义好且已经部署的流程定义的<code>key</code>创建（启动）流程实例。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 得到ProcessEngine对象</span><br><span class="hljs-type">ProcessEngine</span> <span class="hljs-variable">processEngine</span> <span class="hljs-operator">=</span> ProcessEngines.getDefaultProcessEngine();<br><br><span class="hljs-comment">// 得到RuntimeService对象</span><br><span class="hljs-type">RuntimeService</span> <span class="hljs-variable">runtimeService</span> <span class="hljs-operator">=</span> processEngine.getRuntimeService();<br><br><span class="hljs-comment">// 创建流程实例 根据流程定义的key创建实例</span><br><span class="hljs-type">ProcessInstance</span> <span class="hljs-variable">processInstance</span> <span class="hljs-operator">=</span> runtimeService.startProcessInstanceByKey(<span class="hljs-string">&quot;holiday&quot;</span>);<br><br><span class="hljs-comment">// 输出实例的相关信息</span><br>System.out.println(<span class="hljs-string">&quot;流程部署ID：&quot;</span> + processInstance.getDeploymentId()); <span class="hljs-comment">// 流程部署ID：null</span><br>System.out.println(<span class="hljs-string">&quot;流程实例ID：&quot;</span> + processInstance.getId()); <span class="hljs-comment">// 流程实例ID：2501</span><br></code></pre></td></tr></table></figure></li><li><p>可以发现，在启动流程实例后，可以获得已经启动的流程实例的ID。</p></li></ul></li><li><p>涉及到的表</p><ul><li><p><code>act_hi_actinst</code>：存储已完成的活动信息，即已经完成了流程图中的哪些结点信息。</p><img src="/2022/07/13/Activiti/image-20210506204111160.png" class="" title="act_hi_actinst表变化"></li><li><p><code>act_hi_identitylink</code>：流程中结点关联的参与者信息（即需要处理该结点的人员信息）。</p><img src="/2022/07/13/Activiti/image-20210506204339098.png" class="" title="act_hi_identitylink表变化"></li><li><p><code>act_hi_procinst</code>：存储流程实例信息，主要关注流程实例ID。</p><img src="/2022/07/13/Activiti/image-20210506204627408.png" class="" title="表变化"></li><li><p><code>act_hi_taskinst</code>：存储任务实例（谁要完成什么工作）信息。</p><img src="/2022/07/13/Activiti/image-20210506204931866.png" class=""><img src="/2022/07/13/Activiti/image-20210506205012680.png" class=""></li><li><p><code>act_ru_execution</code>：任务执行表。</p><img src="/2022/07/13/Activiti/image-20210506205218650.png" class=""><img src="/2022/07/13/Activiti/image-20210506205303051.png" class=""><img src="/2022/07/13/Activiti/image-20210506205341435.png" class=""></li><li><p><code>act_ru_identitylink</code>：运行时的参与者信息。</p><img src="/2022/07/13/Activiti/image-20210506205520131.png" class=""></li><li><p><code>act_ru_task</code>：存储任务信息。</p><img src="/2022/07/13/Activiti/image-20210506205712061.png" class=""><img src="/2022/07/13/Activiti/image-20210506205742097.png" class=""></li></ul></li></ul><h3 id="（4）任务查询"><a href="#（4）任务查询" class="headerlink" title="（4）任务查询"></a><strong>（4）任务查询</strong></h3><ul><li><p>流程实例启动以后，各个任务的负责人就可以查询自己当前需要处理的任务，查询出来的所有任务都是该用户当前需要处理的待办任务。</p></li><li><p>查询方法如下：</p><ul><li><p>首先仍然需要得到<code>ProcessEngine</code>对象，并通过该对象实例创建<code>TaskService</code>对象（用户需要处理的待办结点事项就是任务）；</p></li><li><p>根据流程定义的<code>key</code>和任务参与者信息（流程定义时指定的结点负责人）查询得到该用于当前需要处理的任务。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 得到ProcessEngine对象</span><br><span class="hljs-type">ProcessEngine</span> <span class="hljs-variable">processEngine</span> <span class="hljs-operator">=</span> ProcessEngines.getDefaultProcessEngine();<br><br><span class="hljs-comment">// 得到TaskService对象</span><br><span class="hljs-type">TaskService</span> <span class="hljs-variable">taskService</span> <span class="hljs-operator">=</span> processEngine.getTaskService();<br><br><span class="hljs-comment">// 根据用户信息查询当前需要处理的任务</span><br>List&lt;Task&gt; taskList = taskService.createTaskQuery().processDefinitionKey(<span class="hljs-string">&quot;holiday&quot;</span>)<br>    .taskAssignee(<span class="hljs-string">&quot;zhangsan&quot;</span>)<br>    .list();<br><br><span class="hljs-comment">// 任务列表内容展示</span><br><span class="hljs-keyword">for</span> (Task task : taskList) &#123;<br>    System.out.println(<span class="hljs-string">&quot;流程实例ID：&quot;</span> + task.getProcessInstanceId()); <span class="hljs-comment">// 流程实例ID：2501</span><br>    System.out.println(<span class="hljs-string">&quot;任务ID：&quot;</span> + task.getId()); <span class="hljs-comment">// 任务ID：2505</span><br>    System.out.println(<span class="hljs-string">&quot;任务负责人：&quot;</span> + task.getAssignee()); <span class="hljs-comment">// 任务负责人：zhangsan</span><br>    System.out.println(<span class="hljs-string">&quot;任务名称：&quot;</span> + task.getName()); <span class="hljs-comment">// 任务名称：填写请假申请单</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>可以发现，查询任务负责人所要处理的任务信息，主要是查询上面在启动流程实例后的一些表信息。</p></li></ul><h3 id="（5）任务处理"><a href="#（5）任务处理" class="headerlink" title="（5）任务处理"></a><strong>（5）任务处理</strong></h3><ul><li><p>任务负责人查询到待办任务，选择任务进行处理，完成任务。</p></li><li><p>该步骤的进行，依赖于上述任务的查询，需要首先查询到当前用户（负责人）需要处理流程中的哪些任务，故可以在正式开发时将查询和处理合并到一起进行。方法如下：</p><ul><li><p>根据参与者信息和流程定义的<code>key</code>查询到需要处理的任务ID；</p></li><li><p>将对应ID的任务处理，调用<code>TaskService</code>对象的<code>complete</code>方法即可。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 得到ProcessEngine对象</span><br><span class="hljs-type">ProcessEngine</span> <span class="hljs-variable">processEngine</span> <span class="hljs-operator">=</span> ProcessEngines.getDefaultProcessEngine();<br><br><span class="hljs-comment">// 得到TaskService对象</span><br><span class="hljs-type">TaskService</span> <span class="hljs-variable">taskService</span> <span class="hljs-operator">=</span> processEngine.getTaskService();<br><br><span class="hljs-comment">// 完成任务</span><br>List&lt;Task&gt; taskList = taskService.createTaskQuery().processDefinitionKey(<span class="hljs-string">&quot;holiday&quot;</span>)<br>    .taskAssignee(<span class="hljs-string">&quot;zhangsan&quot;</span>)<br>    .list();<br><span class="hljs-keyword">for</span> (Task task : taskList) &#123;<br>    taskService.complete(task.getId());<br>    System.out.println(<span class="hljs-string">&quot;当前完成的任务ID是：&quot;</span> + task.getId()); <span class="hljs-comment">// 当前完成的任务ID是：2505</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>可以发现，当当前用户只有一条需要完成的任务时，只输出一条任务信息。</p></li></ul><ul><li><p>涉及到的表</p><ul><li><p><code>act_hi_actinst</code>：存储已完成的任务结点信息。可以发现，在结点一被处理以后，新的结点被加入进来。</p><img src="/2022/07/13/Activiti/image-20210506212852855.png" class=""></li><li><p><code>act_hi_identitylink</code>：新的任务结点加入进来，加入新的任务负责人信息。</p><img src="/2022/07/13/Activiti/image-20210506213037773.png" class=""></li><li><p><code>act_hi_taskinst</code>：新的任务实例被加入进来，同时前一结点的任务加入完成时间。</p><img src="/2022/07/13/Activiti/image-20210506213240227.png" class=""></li><li><p><code>act_ru_execution</code>：执行新的结点任务，更新当前流程任务结点ID。</p><img src="/2022/07/13/Activiti/image-20210506213604364.png" class=""></li><li><p><code>act_ru_identitylink</code>：运行时任务结点的参与者信息，与历史表中的参与者信息一致。</p><img src="/2022/07/13/Activiti/image-20210506213714171.png" class=""></li><li><p><code>act_ru_task</code>：当前运行的任务，保证表中存储的是当前正在运行的结点任务。</p><img src="/2022/07/13/Activiti/image-20210506213839650.png" class=""></li></ul></li><li><p>剩下的任务结点需要改变完成流程任务代码中的参与者信息，待完成所有任务后，上述表中以<code>act_ru</code>开头的表中的信息也会随之被删除，以<code>act_hi</code>开头的表中的信息会被补全。</p></li></ul><p>上面这个流程示例就是一个简单的请假流程，从流程的定义、流程的部署、流程实例的启动以及流程各结点任务的完成。需要说明的是，上面的这个示例是一个单独运行的<code>Activiti</code>流程，没有真正整合到带有流程的<code>Web</code>项目中。</p><h2 id="与业务系统关联"><a href="#与业务系统关联" class="headerlink" title="与业务系统关联"></a>与业务系统关联</h2><ul><li><p>使用<code>BusinessKey</code>（业务主键），该字段在<code>act_ru_execution</code>表中。</p></li><li><p><code>BusinessKey</code>实际上是某个申请表单的<code>ID</code>，如请假流程中的请假表单（业务表），某个人发起一个请假，就会存在一个<code>BusinessKey</code>（业务表的主键）。</p></li><li><p>目的是在查询流程信息时关联查询流程对应的业务信息数据，原因是流程所生成的数据表中不存储业务数据。</p></li></ul><img src="/2022/07/13/Activiti/image-20210604103404886.png" class=""><h2 id="挂起单个流程实例"><a href="#挂起单个流程实例" class="headerlink" title="挂起单个流程实例"></a>挂起单个流程实例</h2><p>对于流程实例的挂起操作，影响的数据表有哪些？影响了哪些字段？</p><p>解答：影响的表有<code>ACT_RU_EXECUTION</code>和<code>ACT_RU_TASK</code>。影响的字段主要有<code>SUSPENSION_STATE_</code>，“1”表示处于激活状态，“2”表示处于挂起状态。状态字段对应的一个接口类是<code>SuspensionState</code>，在该类中定义了状态常量，其实现类是<code>SuspensionStateImpl</code>。</p><p>当对一个挂起的流程实例执行其任务时，会报异常，异常信息为：</p><p><code>Exception in thread &quot;main&quot; org.activiti.engine.ActivitiException: Cannot complete a suspended task     at org.activiti.engine.impl.cmd.NeedsActiveTaskCmd.execute(NeedsActiveTaskCmd.java:53)     at org.activiti.engine.impl.interceptor.CommandInvoker$1.run(CommandInvoker.java:37)     at org.activiti.engine.impl.interceptor.CommandInvoker.executeOperation(CommandInvoker.java:78)     at org.activiti.engine.impl.interceptor.CommandInvoker.executeOperations(CommandInvoker.java:57)     at org.activiti.engine.impl.interceptor.CommandInvoker.execute(CommandInvoker.java:42)     at org.activiti.engine.impl.interceptor.TransactionContextInterceptor.execute(TransactionContextInterceptor.java:48)     at org.activiti.engine.impl.interceptor.CommandContextInterceptor.execute(CommandContextInterceptor.java:63)     at org.activiti.engine.impl.interceptor.LogInterceptor.execute(LogInterceptor.java:29)     at org.activiti.engine.impl.cfg.CommandExecutorImpl.execute(CommandExecutorImpl.java:44)     at org.activiti.engine.impl.cfg.CommandExecutorImpl.execute(CommandExecutorImpl.java:39)     at org.activiti.engine.impl.TaskServiceImpl.complete(TaskServiceImpl.java:192)     at com.poetr.activiti.ActivitiCompleteTask.main(ActivitiCompleteTask.java:24)</code></p><h2 id="Activiti中个人任务的分配方式"><a href="#Activiti中个人任务的分配方式" class="headerlink" title="Activiti中个人任务的分配方式"></a>Activiti中个人任务的分配方式</h2><p>固定的方式：在定义流程时指定特定的人。</p><p>(Activiti.assets\image-20210805230247939.png %}</p><p>使用UEL表达式：</p><ul><li><p>UEL（Unified Expression Language） 统一表达式语言，是Java EE6规范的一部分</p></li><li><p>activiti支持两个UEL表达式：UEL-value，UEL-method</p></li></ul><img src="/2022/07/13/Activiti/image-20210805231256151.png" class=""><p>使用监听器方式：</p><ul><li><p>任务监听器方式是发生对应的任务相关事件时执行自定义Java逻辑 或 表达式（同UEL表达式）</p></li><li><img src="/2022/07/13/Activiti/image-20210809194514640.png" class=""></li><li><p>create：任务创建后触发</p><p>assignment：任务分配后触发</p><p>complete：任务完成后触发</p><p>all：所有事件发生都触发</p></li></ul><h2 id="使用UEL表达式为流程实例分配执行人"><a href="#使用UEL表达式为流程实例分配执行人" class="headerlink" title="使用UEL表达式为流程实例分配执行人"></a>使用UEL表达式为流程实例分配执行人</h2><ul><li><p>通过这种方式为流程指定任务执行人时，需要在启动流程实例时为UEL指定的<code>key</code>指派具体的<code>value</code></p></li><li><p>```java<br>// 设置assignee的取值 用户可以在界面上设置流程的执行人<br>Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();<br>map.put(“assignee0”, “zhangsan”); // key必须与UEL表达式中的Key一致<br>map.put(“assignee1”, “lisi”);<br>map.put(“assignee2”, “wangwu”);</p><p>// 启动流程实例 同时还要设置流程定义中assignee的值<br>ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(“holiday”, map); // 将指派值作为参数传入</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>- 上面指定的值，在Activiti中称之为流程变量<br><br>- 执行上述操作之后，影响的数据表是`act_ru_variable`，在该表中存储流程变量信息<br><br>- &#123;% asset_img image<span class="hljs-number">-20210809194248144.</span>png %&#125;<br><br><br><br>### 流程变量<br><br>- 流程变量是为了让流程更有效的运转；在与业务系统整合时，流程变量不可或缺；时Activiti在管理工作流时为了管理需要而设置的变量<br><br>- 类型<br><br>  &#123;% asset_img image<span class="hljs-number">-20210809200243735.</span>png %&#125;<br><br>- 作用域<br><br>  默认是一个流程实例（processInstance）——&gt;global变量；也可以设置为一个任务（task）和一个执行实例（execution）——&gt;local变量。<br><br>  在不同的位置设置，作用于不同的作用域：在启动流程实例时设置，作用于整个流程实例；在完成某一任务时，则作用于之后的流程实例节点；通过当前任务设置变量，作用于当前任务，当前任务必须是待办任务，否则异常。<br><br>  ```java<br>  <span class="hljs-comment">// 启动流程实例时</span><br>  runtimeService.<span class="hljs-built_in">startProcessInstanceByKey</span>(<span class="hljs-string">&quot;holiday&quot;</span>, map); <span class="hljs-comment">// map为Map集合</span><br>  <br>  <span class="hljs-comment">// 完成某一任务时</span><br>  taskService.<span class="hljs-built_in">complete</span>(taskId, map);<br>  <br>  <span class="hljs-comment">// 通过当前任务</span><br>  taskService.<span class="hljs-built_in">setVariables</span>(taskId, map);<br></code></pre></td></tr></table></figure></li><li><p>使用</p><p>可以将流程变量设置在流程的线上，连线上的UEL表达式决定了流程的走向</p></li><li><p>影响的表</p><p><code>act_ru_variable</code></p><p><code>act_ge_bytearray</code> 类型为Java对象时影响该表</p></li><li><p>当某个流程实例结束之后，变量表中与该流程实例相关的变量便会全部被删除</p></li><li><p>流程中使用过的变量，在流程结束后，存在于<code>act_hi_varinst</code>表中</p></li></ul><h2 id="组任务"><a href="#组任务" class="headerlink" title="组任务"></a>组任务</h2><ul><li><p>候选人的设置是为了更好的提升流程的可扩展性，而非固定的只能由一个人执行某一任务（Candidate users）</p></li><li><p>设置候选人会影响的表有<code>act_ru_identitylink</code>和<code>act_hi_identitylink</code>，候选人的<code>type</code>字段为<code>candidant</code></p><img src="/2022/07/13/Activiti/image-20210810195657263.png" class=""></li><li><p>办理组任务的流程：</p><ul><li>查询组任务（根据指定的候选人信息查询可以办理的组任务，候选人不能办理组任务）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 查询组任务</span><br>List&lt;Task&gt; taskList = taskService.createTaskQuery().processDefinitionKey(<span class="hljs-string">&quot;holiday&quot;</span>)<br>    .taskCandidateUser(<span class="hljs-string">&quot;huahua&quot;</span>) <span class="hljs-comment">// 根据候选人查询</span><br>    .list();<br></code></pre></td></tr></table></figure><ul><li>拾取（claim）任务，就是将组任务变成个人任务；拾取后不想办理可将任务还到组里（拾取前最好先校验该用户有没有拾取权限），还可将任务交接给候选组中的指定候选人</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 校验用户有没有拾取任务的资格</span><br><span class="hljs-type">Task</span> <span class="hljs-variable">taskResult</span> <span class="hljs-operator">=</span> taskService.createTaskQuery().taskId(<span class="hljs-string">&quot;5002&quot;</span>)<br>    .taskCandidateUser(<span class="hljs-string">&quot;huahua&quot;</span>)<br>    .singleResult();<br><br><span class="hljs-comment">// 拾取任务</span><br><span class="hljs-keyword">if</span> (taskResult != <span class="hljs-literal">null</span>) &#123;<br>    taskService.claim(taskResult.getId(), <span class="hljs-string">&quot;huahua&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;当前拾取的任务ID是：&quot;</span> + taskResult.getId());<br>&#125;<br><br><span class="hljs-comment">// 归还组任务,先进行校验</span><br><span class="hljs-type">Task</span> <span class="hljs-variable">taskResult</span> <span class="hljs-operator">=</span> taskService.createTaskQuery().taskId(<span class="hljs-string">&quot;5002&quot;</span>)<br>    .taskAssignee(<span class="hljs-string">&quot;huahua&quot;</span>)<br>    .singleResult();<br><br><span class="hljs-comment">// 不想办理时归还组任务</span><br><span class="hljs-keyword">if</span> (taskResult != <span class="hljs-literal">null</span>) &#123;<br>    taskService.setAssignee(<span class="hljs-string">&quot;5002&quot;</span>, <span class="hljs-literal">null</span>);<br>    System.out.println(<span class="hljs-string">&quot;当前归还的任务ID是：&quot;</span> + taskResult.getId());<br>&#125;<br><br><span class="hljs-comment">// 交接组任务,先进行校验</span><br><span class="hljs-type">Task</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> taskService.createTaskQuery().taskId(<span class="hljs-string">&quot;5002&quot;</span>)<br>    .taskAssignee(<span class="hljs-string">&quot;huahua&quot;</span>)<br>    .singleResult();<br><br><span class="hljs-keyword">if</span> (task != <span class="hljs-literal">null</span>) &#123;<br>    taskService.setAssignee(<span class="hljs-string">&quot;5002&quot;</span>, <span class="hljs-string">&quot;lisi&quot;</span>); <span class="hljs-comment">// 将任务交接给另一候选人</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​        拾取任务成功后，会在当前任务表中的<code>assignee</code>字段赋值。</p><p>​        拾取前：</p><p>​    <img src="/2022/07/13/Activiti/image-20210809233858149.png" class=""></p><p>​        拾取后：</p><p>​    <img src="/2022/07/13/Activiti/image-20210809233207963.png" class=""></p><ul><li><p>查询个人任务</p><p>拾取组任务之后，可以与个人任务的查询一致，进行负责人任务的查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用户查询个人待办任务(与普通任务一致)</span><br>List&lt;Task&gt; list = taskService.createTaskQuery().processDefinitionKey(<span class="hljs-string">&quot;holiday&quot;</span>)<br>    .taskAssignee(<span class="hljs-string">&quot;huahua&quot;</span>)<br>    .list();<br><br><span class="hljs-keyword">for</span> (Task task : list) &#123;<br>    System.out.println(<span class="hljs-string">&quot;-----------------------&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;流程实例ID：&quot;</span> + task.getProcessInstanceId());<br>    System.out.println(<span class="hljs-string">&quot;任务ID：&quot;</span> + task.getId());<br>    System.out.println(<span class="hljs-string">&quot;任务负责人：&quot;</span> + task.getAssignee());<br>    System.out.println(<span class="hljs-string">&quot;任务名称：&quot;</span> + task.getName());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>办理个人任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用户办理个人任务（同个人任务办理）</span><br><span class="hljs-type">Task</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> taskService.createTaskQuery().processDefinitionKey(<span class="hljs-string">&quot;holiday&quot;</span>)<br>    .taskAssignee(<span class="hljs-string">&quot;huahua&quot;</span>)<br>    .singleResult();<br><br><span class="hljs-keyword">if</span> (task != <span class="hljs-literal">null</span>) &#123;<br>    taskService.complete(task.getId());<br>    System.out.println(<span class="hljs-string">&quot;当前完成的任务是：&quot;</span> + task.getId());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><ul><li><p>使用到的Activiti网关主要有排他网关（XOR网关、异或网关）、并行网关和包含网关</p></li><li><p>网关的出现是为了支持流程的多路径</p></li><li><p>排他网关</p><ul><li><p>用来在流程中实现决策</p></li><li><p>每一只能选择一条满足条件的路径执行，都不满足时报Activiti异常</p></li><li><p>任务执行到网关后，会在<code>act_hi_actinst</code>表中插入数据</p><img src="/2022/07/13/Activiti/image-20210810205707805.png" class=""></li></ul></li></ul><ul><li><p>并行网关</p><ul><li><p>并行网关允许将流程分成多条分支，也可以把多条分支汇聚到一起</p></li><li><p>并行网关的功能是基于进入和外出顺序流的</p></li><li><p>并行网关不会解析条件，即使顺序流中定义了条件，也会被忽略</p></li><li><p>并行节点处会在当前执行任务表中同时存在等于输出流总数的记录数，而一般只存在一条当前执行任务</p><img src="/2022/07/13/Activiti/image-20210810214700323.png" class=""></li><li><p>所有分支到达汇聚结点，并行网关执行完成</p></li></ul></li></ul><ul><li>排他网关</li><li>是排他网关和并行网关结合体</li></ul></li></ul><h2 id="？-flowable"><a href="#？-flowable" class="headerlink" title="？ flowable"></a>？ flowable</h2>]]></content>
    
    
    <categories>
      
      <category>工作流</category>
      
      <category>Activiti</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
