

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/miderl.png">
  <link rel="icon" href="/img/miderl.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="MiderL">
  <meta name="keywords" content="">
  
    <meta name="description" content="计算机网络为什么要对网络协议进行分层 易于实现和维护，因为各层之间是独立的，层与层之间不会受到影响  有利于标准化的制定 计算机网络的各层协议及作用  应用层   应用层的任务是通过应用进程之间的交互来完成特定的网络作用，常见的应用层协议有域名系统DNS, HTTP协议等。  表示层  表示层的主要作用是数据的表示、安全、压缩。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。  会">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题库">
<meta property="og:url" content="https://miderl.github.io/2022/08/02/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/index.html">
<meta property="og:site_name" content="MiderL">
<meta property="og:description" content="计算机网络为什么要对网络协议进行分层 易于实现和维护，因为各层之间是独立的，层与层之间不会受到影响  有利于标准化的制定 计算机网络的各层协议及作用  应用层   应用层的任务是通过应用进程之间的交互来完成特定的网络作用，常见的应用层协议有域名系统DNS, HTTP协议等。  表示层  表示层的主要作用是数据的表示、安全、压缩。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。  会">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658494699266-3d3fc9cb-5fc4-4bff-af85-f4217cfa4152.png#clientId=uf0be6986-5431-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=786&id=u94b21744&margin=%5Bobject%20Object%5D&name=image.png&originHeight=786&originWidth=835&originalType=binary&ratio=1&rotation=0&showTitle=false&size=84362&status=done&style=none&taskId=u66cebb8a-3fe3-488d-be1c-f8fb280fa04&title=&width=835">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658912312264-b1956113-faa9-43dc-928f-fd4bcf3902fe.png#clientId=u59fe761c-a5e8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=738&id=uc732643e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=738&originWidth=1090&originalType=binary&ratio=1&rotation=0&showTitle=false&size=619131&status=done&style=none&taskId=u45e22781-b8a2-4707-adbc-d81855b54e0&title=&width=1090">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658912491180-733c42d7-79c6-4d39-8d38-0ceeffaa4a3d.png#clientId=u59fe761c-a5e8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=482&id=u8f31f05e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=482&originWidth=904&originalType=binary&ratio=1&rotation=0&showTitle=false&size=320817&status=done&style=none&taskId=u76d8c39c-a4f9-4f62-be8f-11aaf10374a&title=&width=904">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658546491194-41a5d5f2-8d33-4a18-a1e1-21eeb05c0de1.png#clientId=ua6c321be-9ac9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=588&id=u9662ea21&margin=%5Bobject%20Object%5D&name=image.png&originHeight=588&originWidth=901&originalType=binary&ratio=1&rotation=0&showTitle=false&size=102153&status=done&style=none&taskId=uacf313c3-85ac-48e0-8946-2b8402d80c2&title=&width=901">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658566143708-10ee464d-303e-4694-8c90-8420d258169e.png#clientId=ua6c321be-9ac9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=637&id=u2fae9d90&margin=%5Bobject%20Object%5D&name=image.png&originHeight=637&originWidth=905&originalType=binary&ratio=1&rotation=0&showTitle=false&size=353527&status=done&style=none&taskId=u50c1dfaf-b406-46a9-b331-f4e0fe83a68&title=&width=905">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1656238538349-c58f550f-8a41-4df2-8865-d6d9cf585995.png#clientId=u53df3f19-1c59-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=698&id=u878e811b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=698&originWidth=694&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74195&status=done&style=none&taskId=u59dc4b32-9439-4310-9c0b-f7d266de203&title=&width=694">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1656249887891-7f5f02e7-698a-45d8-bd4b-ae772406d6c1.png#clientId=ufe945330-ab88-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=495&id=uc100b797&margin=%5Bobject%20Object%5D&name=image.png&originHeight=495&originWidth=936&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74443&status=done&style=none&taskId=u16e98cf8-9a1f-4f33-b5b8-5a23485da31&title=&width=936">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1656249966677-6a95b401-c4ab-408b-8e76-5ff5c1654d24.png#clientId=ufe945330-ab88-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=328&id=u4de0e1c8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=328&originWidth=986&originalType=binary&ratio=1&rotation=0&showTitle=false&size=44516&status=done&style=none&taskId=u2585481f-34a5-4f11-90e6-8131d90f211&title=&width=986">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1659337132321-2133429a-8a3e-429b-aff6-c6a4d7843a8e.png#clientId=u1e77df9b-6dc6-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=301&id=u52932632&margin=%5Bobject%20Object%5D&name=image.png&originHeight=301&originWidth=506&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10148&status=done&style=none&taskId=u36bff6c3-ccd4-4c5f-8477-83c66cf7924&title=&width=506">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658906869689-c522e379-464d-4fac-8b8d-bc5b89cbce48.png#clientId=u45035bbf-2508-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=785&id=u843e5c79&margin=%5Bobject%20Object%5D&name=image.png&originHeight=785&originWidth=1161&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49283&status=done&style=none&taskId=u9cd1823b-675c-4e8e-8957-7545af12ff2&title=&width=1161">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658907006317-7bafc8ec-6733-44c8-a83f-3638975ac3cf.png#clientId=u45035bbf-2508-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=720&id=u66517a2e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=720&originWidth=1083&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111411&status=done&style=none&taskId=u8f960b47-9d57-49ec-83c0-5a5ca5c5623&title=&width=1083">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1659427849422-4f9f3496-d301-4c94-8176-496ff8503ff9.png#clientId=ud96b3449-5125-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=527&id=u0ff5fe23&margin=%5Bobject%20Object%5D&name=image.png&originHeight=527&originWidth=829&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66942&status=done&style=none&taskId=u669ee662-1769-4356-9045-a2cb56f9833&title=&width=829">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657075232431-2957e6e2-f6fb-46c9-b7e7-0f6116bf1f58.png#clientId=ucd4d0f03-b44f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=295&id=uadf0d605&margin=%5Bobject%20Object%5D&name=image.png&originHeight=295&originWidth=998&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29364&status=done&style=none&taskId=u2b63b606-ec86-49ec-9e4d-c60527200fb&title=&width=998">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657078043672-b407d9b2-2ea3-4581-a935-16207d307e75.png#clientId=uef0d43a0-2438-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc1987776&margin=%5Bobject%20Object%5D&originHeight=268&originWidth=223&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u492f9c3c-35ff-40f6-b493-f915e7e1d44&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657094320326-950c7c8e-c2da-4a52-847d-8efb787f5e1c.png#clientId=uef0d43a0-2438-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=574&id=udf0cbdbd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=574&originWidth=1120&originalType=binary&ratio=1&rotation=0&showTitle=false&size=232096&status=done&style=none&taskId=u8801258c-0eb5-4a5f-9779-b275f64f9cd&title=&width=1120">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657094576572-a8bb76ab-a6dc-4e45-bd47-f18bce9702a9.png#clientId=uef0d43a0-2438-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=558&id=ub108f54e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=558&originWidth=1125&originalType=binary&ratio=1&rotation=0&showTitle=false&size=199935&status=done&style=none&taskId=u9f236c2f-1274-4ac2-8489-2ba68cf66a2&title=&width=1125">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657267387921-d1f582e0-0be8-4736-9a13-39c78503755a.png#clientId=udfed2b78-8c5f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=653&id=u1dd1d734&margin=%5Bobject%20Object%5D&name=image.png&originHeight=653&originWidth=1156&originalType=binary&ratio=1&rotation=0&showTitle=false&size=291421&status=done&style=none&taskId=u33dc7fb4-4ca9-4f30-b2ba-528109f8135&title=&width=1156">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657678603571-2ff051ea-bf2e-4847-ace4-25a194174627.png#clientId=u005da07f-0361-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=537&id=ue188f49b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=790&originWidth=798&originalType=binary&ratio=1&rotation=0&showTitle=false&size=422313&status=done&style=none&taskId=ud973c139-0ea8-48a8-945c-1f0557874e9&title=&width=542">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657444407108-37d950db-1abe-4d12-af32-8ae4c1967775.png#clientId=u48d5a21b-2cf2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=297&id=u15211376&margin=%5Bobject%20Object%5D&name=image.png&originHeight=297&originWidth=1380&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18697&status=done&style=none&taskId=ua62f516f-affe-4e1b-a4c5-fbb2ace0f5c&title=&width=1380">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657532366196-b520333e-bb31-423e-9b2b-95182d306caf.png#clientId=uc8c1e3f3-896e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=849&id=u3a555976&margin=%5Bobject%20Object%5D&name=image.png&originHeight=849&originWidth=984&originalType=binary&ratio=1&rotation=0&showTitle=false&size=237682&status=done&style=none&taskId=u111f3c45-8e7f-4a69-a4c6-8c4a5220842&title=&width=984">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658299153930-09bd88a8-81f4-40f9-b922-aa4b82669894.png#clientId=u146ac9cd-79d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=563&id=uffdfa075&margin=%5Bobject%20Object%5D&name=image.png&originHeight=563&originWidth=1164&originalType=binary&ratio=1&rotation=0&showTitle=false&size=260108&status=done&style=none&taskId=u3eba2e6a-e93d-4e18-8e58-21585ea2af5&title=&width=1164">
<meta property="article:published_time" content="2022-08-02T09:12:57.000Z">
<meta property="article:modified_time" content="2022-08-02T09:18:31.754Z">
<meta property="article:author" content="MiderL">
<meta property="article:tag" content="原创">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658494699266-3d3fc9cb-5fc4-4bff-af85-f4217cfa4152.png#clientId=uf0be6986-5431-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=786&id=u94b21744&margin=%5Bobject%20Object%5D&name=image.png&originHeight=786&originWidth=835&originalType=binary&ratio=1&rotation=0&showTitle=false&size=84362&status=done&style=none&taskId=u66cebb8a-3fe3-488d-be1c-f8fb280fa04&title=&width=835">
  
  
  
  <title>面试题库 - MiderL</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"miderl.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"OkhbwGMKq8QHprfkicG7YrD1-gzGzoHsz","app_key":"YKOtvJConydfNHSzzY08cEao","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>MiderL</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面试题库"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-02 17:12" pubdate>
          2022年8月2日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          27k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          227 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面试题库</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="为什么要对网络协议进行分层"><a href="#为什么要对网络协议进行分层" class="headerlink" title="为什么要对网络协议进行分层"></a>为什么要对网络协议进行分层</h2><ul>
<li><p>易于实现和维护，因为各层之间是独立的，层与层之间不会受到影响</p>
</li>
<li><p>有利于标准化的制定</p>
<h2 id="计算机网络的各层协议及作用"><a href="#计算机网络的各层协议及作用" class="headerlink" title="计算机网络的各层协议及作用"></a>计算机网络的各层协议及作用</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658494699266-3d3fc9cb-5fc4-4bff-af85-f4217cfa4152.png#clientId=uf0be6986-5431-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=786&id=u94b21744&margin=%5Bobject%20Object%5D&name=image.png&originHeight=786&originWidth=835&originalType=binary&ratio=1&rotation=0&showTitle=false&size=84362&status=done&style=none&taskId=u66cebb8a-3fe3-488d-be1c-f8fb280fa04&title=&width=835" srcset="/img/loading.gif" lazyload alt="image.png"></p>
</li>
<li><p>应用层</p>
</li>
</ul>
<p>应用层的任务是通过应用进程之间的交互来完成特定的网络作用，常见的应用层协议有域名系统DNS, HTTP协议等。</p>
<ul>
<li>表示层</li>
</ul>
<p>表示层的主要作用是数据的表示、安全、压缩。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</p>
<ul>
<li>会话层</li>
</ul>
<p>会话层的主要作用是建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。</p>
<ul>
<li>传输层</li>
</ul>
<p>传输层的主要作用是负责向两台主机进程之间的通信提供数据传输服务。传输层的协议主要有传输控制协议TCP和用户数据协议UDP。</p>
<ul>
<li>网络层</li>
</ul>
<p>网络层的主要作用是选择合适的网间路由和交换结点，确保数据及时送达。常见的协议有IP协议。</p>
<ul>
<li>数据链路层</li>
</ul>
<p>数据链路层的作用是在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧(Frame) 在信道上无差错的传输，并进行各电路上的动作系列。常见的协议有SDLC、HDLC、PPP等。</p>
<ul>
<li>物理层</li>
</ul>
<p>物理层的主要作用是实现相邻计算机结点之间比特流的透明传输，并尽量屏蔽掉具体传输质和物理设备的差异。</p>
<h2 id="TCP与UDP有什么区别"><a href="#TCP与UDP有什么区别" class="headerlink" title="TCP与UDP有什么区别"></a>TCP与UDP有什么区别</h2><table>
<thead>
<tr>
<th></th>
<th><strong>是否面向连接</strong></th>
<th><strong>可靠性</strong></th>
<th><strong>传输模式</strong></th>
<th><strong>传输效率</strong></th>
<th><strong>消耗资源</strong></th>
<th><strong>应用场景</strong></th>
<th><strong>首部字节</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>TCP</strong></td>
<td>是</td>
<td>可靠</td>
<td>字节流</td>
<td>慢</td>
<td>多</td>
<td>文件/邮件传输</td>
<td>20-60</td>
</tr>
<tr>
<td><strong>UDP</strong></td>
<td>否</td>
<td>不可靠</td>
<td>数据报文段</td>
<td>快</td>
<td>少</td>
<td>视频/语音传输</td>
<td>8</td>
</tr>
</tbody></table>
<h3 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h3><p>前20个字节是固定的，后面有4n个字节是根据需而增加的选项，所以TCP首部最小长度为20字节。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658912312264-b1956113-faa9-43dc-928f-fd4bcf3902fe.png#clientId=u59fe761c-a5e8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=738&id=uc732643e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=738&originWidth=1090&originalType=binary&ratio=1&rotation=0&showTitle=false&size=619131&status=done&style=none&taskId=u45e22781-b8a2-4707-adbc-d81855b54e0&title=&width=1090" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="UDP首部"><a href="#UDP首部" class="headerlink" title="UDP首部"></a>UDP首部</h3><p>UDP的首部只有8个字节，源端口号、目的端口号、长度和校验和各两个字节。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658912491180-733c42d7-79c6-4d39-8d38-0ceeffaa4a3d.png#clientId=u59fe761c-a5e8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=482&id=u8f31f05e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=482&originWidth=904&originalType=binary&ratio=1&rotation=0&showTitle=false&size=320817&status=done&style=none&taskId=u76d8c39c-a4f9-4f62-be8f-11aaf10374a&title=&width=904" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="TCP协议是如何保证可靠传输"><a href="#TCP协议是如何保证可靠传输" class="headerlink" title="TCP协议是如何保证可靠传输"></a>TCP协议是如何保证可靠传输</h2><blockquote>
<p>主要有校验和、序列号、超时重传、流量控制及拥塞避免等几种方法。</p>
</blockquote>
<h2 id="TCP的三次握手及四次挥手"><a href="#TCP的三次握手及四次挥手" class="headerlink" title="TCP的三次握手及四次挥手"></a>TCP的三次握手及四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658546491194-41a5d5f2-8d33-4a18-a1e1-21eeb05c0de1.png#clientId=ua6c321be-9ac9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=588&id=u9662ea21&margin=%5Bobject%20Object%5D&name=image.png&originHeight=588&originWidth=901&originalType=binary&ratio=1&rotation=0&showTitle=false&size=102153&status=done&style=none&taskId=uacf313c3-85ac-48e0-8946-2b8402d80c2&title=&width=901" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658566143708-10ee464d-303e-4694-8c90-8420d258169e.png#clientId=ua6c321be-9ac9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=637&id=u2fae9d90&margin=%5Bobject%20Object%5D&name=image.png&originHeight=637&originWidth=905&originalType=binary&ratio=1&rotation=0&showTitle=false&size=353527&status=done&style=none&taskId=u50c1dfaf-b406-46a9-b331-f4e0fe83a68&title=&width=905" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="为什么TCP连接的时候是三次"><a href="#为什么TCP连接的时候是三次" class="headerlink" title="为什么TCP连接的时候是三次"></a>为什么TCP连接的时候是三次</h3><p>可以确保建立有效的连接，确保双方都确认连接的有效性。</p>
<h3 id="为什么TCP连接的时候是三次，关闭的时候缺失四次"><a href="#为什么TCP连接的时候是三次，关闭的时候缺失四次" class="headerlink" title="为什么TCP连接的时候是三次，关闭的时候缺失四次"></a>为什么TCP连接的时候是三次，关闭的时候缺失四次</h3><p>TCP通信是全双工的，需要确保通信双方都能通知对方释放连接。</p>
<h3 id="TIME-WAIT和CLOSE-WAIT的区别"><a href="#TIME-WAIT和CLOSE-WAIT的区别" class="headerlink" title="TIME_WAIT和CLOSE_WAIT的区别"></a>TIME_WAIT和CLOSE_WAIT的区别</h3><p>TIME_WAIT是主动发起关闭一方发送释放连接请求后在第四次挥手完成后进入的状态；CLOSE_WAIT是被动关闭一方在其返回给主动关闭一方ACK报文后进入的状态。</p>
<h3 id="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接"><a href="#为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接" class="headerlink" title="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接"></a>为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接</h3><p>基于客户端：<strong>清场</strong>的作用，即使本次TCP连接中的所有报文全部消失，不会出现在下一个TCP连接中。<br>基于服务端：<strong>考虑丢包</strong>，如果第四次挥手报文丢失，服务端会在等待一定时间后重新发送第三次挥手报文，如果客户端直接关闭，则收不到该重新发送的报文，致使服务端无法正常关闭。</p>
<h2 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h2><table>
<thead>
<tr>
<th></th>
<th><strong>HTTP</strong></th>
<th><strong>HTTPS</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>端口</strong></td>
<td>80</td>
<td>443</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>无加密，安全性较差</td>
<td>有加密机制，安全性较高</td>
</tr>
<tr>
<td><strong>资源消耗</strong></td>
<td>较少</td>
<td>由于加密处理，资源消耗较高</td>
</tr>
<tr>
<td><strong>是否需要证书</strong></td>
<td>不需要</td>
<td>需要</td>
</tr>
<tr>
<td><strong>协议</strong></td>
<td>运行在TCP协议之上</td>
<td>运行在SSL协议之上，SSL运行在TCP协议之上</td>
</tr>
</tbody></table>
<h2 id="常用HTTP状态码"><a href="#常用HTTP状态码" class="headerlink" title="常用HTTP状态码"></a>常用HTTP状态码</h2><table>
<thead>
<tr>
<th><strong>状态码</strong></th>
<th><strong>类别</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>信息性状态码</td>
</tr>
<tr>
<td>2XX</td>
<td>成功状态码</td>
</tr>
<tr>
<td>3XX</td>
<td>重定向状态码</td>
</tr>
<tr>
<td>4XX</td>
<td>客户端错误状态码</td>
</tr>
<tr>
<td>5XX</td>
<td>服务端错误状态码</td>
</tr>
</tbody></table>
<h2 id="在浏览器中输入URL到显示主页发生了什么"><a href="#在浏览器中输入URL到显示主页发生了什么" class="headerlink" title="在浏览器中输入URL到显示主页发生了什么"></a>在浏览器中输入URL到显示主页发生了什么</h2><ul>
<li>DNS域名服务器解析输入的域名，找到对应的IP地址</li>
<li>和目的服务器建立TCP连接</li>
<li>向目的服务器发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析并渲染页面</li>
</ul>
<hr>
<h1 id="Java核心知识"><a href="#Java核心知识" class="headerlink" title="Java核心知识"></a>Java核心知识</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>（1）类别</strong></p>
<ul>
<li>静态变量</li>
<li>静态方法</li>
<li>静态代码块<ul>
<li>用于优化程序的性能，因其中的内容只会在类加载时被加载一次</li>
<li>一般将只需要进行一次初始化的操作放入其中</li>
</ul>
</li>
</ul>
<p><strong>（2）技巧</strong></p>
<ul>
<li>判断对象的访问范围时考虑创建时机即可</li>
</ul>
<p><strong>（3）有关的初始化顺序</strong></p>
<ul>
<li>总原则是静态变量和静态语句块优先于实例变量和普通语句块</li>
<li>静态变量和静态语句块的初始化顺序取决于代码中的顺序</li>
<li>存在继承关系，则：<ul>
<li>父类中的静态变量和静态语句块</li>
<li>子类中的静态变量和静态语句块</li>
<li>父类中的实例变量和普通语句块</li>
<li>父类的构造函数</li>
<li>子类的实例变量和普通语句块</li>
<li>子类的构造函数</li>
</ul>
</li>
</ul>
<p><strong>（4）目标</strong><br>static关键字一般用于修饰<strong>变量</strong>和<strong>方法</strong>；特殊用法是可以用于且只能用于修饰<strong>内部类</strong>；被static修饰的内部类可以直接作为一个普通类来使用，而不需要先实例一个外部类。</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final关键字可以用于修饰类、变量和方法；</p>
<ul>
<li><p>被final修饰的类不可以<strong>被继承</strong></p>
</li>
<li><p>被final修饰的方法不可以<strong>被重写</strong></p>
</li>
<li><p>被final修饰的变量</p>
<ul>
<li>基本类型变量：变量的数值不能改变</li>
<li>引用类型变量：变量不能再引用其它对象，但被引用的对象是可以改变的<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3></li>
</ul>
</li>
<li><p>可用来引用当前类的实例变量（主要用于形参与成员名字重名）</p>
</li>
<li><p>可用于调用当前类方法（可省略）</p>
</li>
<li><p>可用来调用当前类的构造函数（this要调用的构造函数一定放在第一行）</p>
<h2 id="Java中子类能否重写父类的类方法-静态方法"><a href="#Java中子类能否重写父类的类方法-静态方法" class="headerlink" title="Java中子类能否重写父类的类方法/静态方法"></a>Java中子类能否重写父类的类方法/静态方法</h2></li>
</ul>
<p><strong>不能</strong>。<br>静态的方法和变量都是属于类的，在该类的字节码文件被加载到内存就分配了相应的内存空间。所以说，即便子类中有一个和父类的类方法长得一摸一样的类方法（方法体可能不同），也不能算重写，因为两者占据不同的内存空间，这个子类的静态方法是子类自己的，与父类没有关系。</p>
<ul>
<li><p>子类可以继承父类的静态方法，但不能重写它；</p>
</li>
<li><p>当子类或子类对象调用该静态方法时，调用的子类的静态方法；</p>
</li>
<li><p>当子类的上转型对象调用该静态方法时，调用的是子类继承的静态方法（即父类的）。</p>
<h2 id="面向对象五大基本原则"><a href="#面向对象五大基本原则" class="headerlink" title="面向对象五大基本原则"></a>面向对象五大基本原则</h2><h3 id="单一职责原则（Single-Responsibility-Principle）"><a href="#单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="单一职责原则（Single-Responsibility Principle）"></a>单一职责原则（Single-Responsibility Principle）</h3></li>
<li><p>一个类最好只做一件事，只有一个引起它的变化</p>
</li>
<li><p>单一引起其变化的原因则是职责</p>
</li>
<li><p>提升高内聚、低耦合水平</p>
<h3 id="开放封闭原则（Open-Closed-Principle）"><a href="#开放封闭原则（Open-Closed-Principle）" class="headerlink" title="开放封闭原则（Open-Closed Principle）"></a>开放封闭原则（Open-Closed Principle）</h3></li>
<li><p>软件实体应该是可扩展的，而不可修改的</p>
</li>
<li><p>对扩展开放，对修改关闭</p>
<h3 id="里氏替换原则（Liskov-Substitution-Principle）"><a href="#里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏替换原则（Liskov Substitution Principle）"></a>里氏替换原则（Liskov Substitution Principle）</h3></li>
<li><p>子类必须能够替换其基类</p>
<h3 id="依赖倒置原则（Dependency-Inversion-Principle）"><a href="#依赖倒置原则（Dependency-Inversion-Principle）" class="headerlink" title="依赖倒置原则（Dependency-Inversion Principle）"></a>依赖倒置原则（Dependency-Inversion Principle）</h3></li>
<li><p>依赖于抽象</p>
</li>
<li><p>高层模块不依赖于底层模块，二者都依赖于抽象</p>
</li>
<li><p>抽象不依赖于具体，具体依赖于抽象</p>
<h3 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface-Segregation Principle）"></a>接口隔离原则（Interface-Segregation Principle）</h3></li>
<li><p>使用多个小的专门的接口，而不使用一个大的总接口</p>
<h2 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="headerlink" title="抽象类和接口的对比"></a>抽象类和接口的对比</h2><p><code>abstract class</code>和<code>interface</code>是Java语言中支持抽象类定义的两种机制。</p>
</li>
<li><p>抽象类：用来捕捉子类的通用特性</p>
</li>
<li><p>接口：抽象方法的集合</p>
</li>
</ul>
<p><strong>相同点：</strong></p>
<ul>
<li>两者都不能实例化</li>
<li>都包含抽象方法，子类必须覆写这些方法</li>
</ul>
<p><strong>不同点：</strong></p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>抽象类</strong></th>
<th><strong>接口</strong></th>
</tr>
</thead>
<tbody><tr>
<td>访问修饰符</td>
<td>抽象方法可以有public、protected和default修饰符</td>
<td>接口方法默认修饰符是public，不可改变</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>字段声明</td>
<td>抽象类的字段声明可以是任意的</td>
<td>接口的字段默认都是static和final的</td>
</tr>
</tbody></table>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p>类变量：独立于方法之外的变量，用static修饰</p>
</li>
<li><p>实例变量：独立于方法之外的变量，没有用static修饰</p>
</li>
<li><p>成员变量：又称全局变量，可分为类变量和实例变量</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类包括四种：成员内部类、局部内部类、匿名内部类、静态内部类</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4></li>
<li><p>成员内部类定义为位于一个类的内部</p>
</li>
<li><p>成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）</p>
</li>
<li><p>外部类访问成员内部类成员时，必须先创建一个成员内部类对象，再通过指向这个对象的引用来访问</p>
</li>
<li><p>成员内部类依附于外部类而存在，如果要创建成员内部类对象，前提是必须存在一个外部类的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClassTest</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 普通成员变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// 静态成员变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 同名变量</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InnerClassTest</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InnerClassTest</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">long</span> c)</span> &#123;<br>        <span class="hljs-built_in">this</span>(a);<br>        <span class="hljs-built_in">this</span>.c = c;<br>    &#125;<br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span> &#123; <span class="hljs-comment">// 内部类</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(a);<br>            System.out.println(b);<br>            System.out.println(InnerClassTest.<span class="hljs-built_in">this</span>.c); <span class="hljs-comment">// 访问外部类同名变量</span><br>            System.out.println(c); <span class="hljs-comment">// 访问内部变量</span><br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4></li>
<li><p>局部内部类是定义在一个方法或者一个作用域里面的类</p>
</li>
<li><p>访问仅限于方法内或作用域内</p>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4></li>
<li><p>指没有名字的内部类</p>
</li>
<li><p>使用前提条件：继承一个父类或者实现一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>;<br>    <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnonymityInnerClass</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Person...&quot;</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4></li>
<li><p>定义在一个类的内部，用static修饰</p>
</li>
<li><p>静态内部类不依赖于外部类，不能访问外部类中非静态成员变量和方法</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3></li>
<li><p>匿名内部类可以很方便的定义回调</p>
</li>
<li><p>内部类最吸引人的：每个内部类都能独自继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没影响</p>
</li>
<li><p>内部类有效实现了“多重继承”，优化Java中单继承的缺陷</p>
<h2 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h2></li>
</ul>
<p><strong>值传递：</strong>是指在函数调用时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数<br><strong>引用传递：</strong>是指在函数调用时将实际参数的地址直接传递到函数中，则在函数中对参数进行的修改，将影响到实际参数</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><strong>序列化：</strong>将对象写入到IO流中<br><strong>反序列化：</strong>从IO流中恢复对象<br><strong>实现方式：</strong></p>
<ul>
<li>实现<code>Serializable</code>接口</li>
<li>实现<code>Externalizable</code>接口</li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li><p>对象的类名、实例变量会被序列化</p>
</li>
<li><p>方法、类变量、<code>transient</code>实例变量都不会被序列化</p>
</li>
<li><p>某个变量不想被序列化，可以使用<code>transient</code>修饰</p>
</li>
<li><p>序列化对象的引用类型成员变量，必须是可序列化的否则会报错</p>
</li>
<li><p>反序列化时必须有序列化对象的<code>class</code>文件</p>
<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2></li>
<li><p><strong>深拷贝：</strong>对基本数据类型进行值传递；对引用数据类型，创建一个新对象，并复制其内容，两个引用指向两个对象，但对象的内容相同</p>
</li>
<li><p><strong>浅拷贝：</strong>对基本数据类型进行值传递；对引用数据类型复制一个引用指向原始引用对象，即复制的引用和原始引用指向同一个对象</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1656238538349-c58f550f-8a41-4df2-8865-d6d9cf585995.png#clientId=u53df3f19-1c59-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=698&id=u878e811b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=698&originWidth=694&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74195&status=done&style=none&taskId=u59dc4b32-9439-4310-9c0b-f7d266de203&title=&width=694" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<hr>
<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><h2 id="常用的集合类"><a href="#常用的集合类" class="headerlink" title="常用的集合类"></a>常用的集合类</h2><ul>
<li>Map接口和Collection接口是所有集合框架的父接口</li>
<li>Collection接口不是Map的父接口</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1656249887891-7f5f02e7-698a-45d8-bd4b-ae772406d6c1.png#clientId=ufe945330-ab88-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=495&id=uc100b797&margin=%5Bobject%20Object%5D&name=image.png&originHeight=495&originWidth=936&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74443&status=done&style=none&taskId=u16e98cf8-9a1f-4f33-b5b8-5a23485da31&title=&width=936" srcset="/img/loading.gif" lazyload alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1656249966677-6a95b401-c4ab-408b-8e76-5ff5c1654d24.png#clientId=ufe945330-ab88-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=328&id=u4de0e1c8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=328&originWidth=986&originalType=binary&ratio=1&rotation=0&showTitle=false&size=44516&status=done&style=none&taskId=u2585481f-34a5-4f11-90e6-8131d90f211&title=&width=986" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<hr>
<h1 id="Java并发编程"><a href="#Java并发编程" class="headerlink" title="Java并发编程"></a>Java并发编程</h1><h2 id="用Java实现死锁，并给出避免死锁的解决方案"><a href="#用Java实现死锁，并给出避免死锁的解决方案" class="headerlink" title="用Java实现死锁，并给出避免死锁的解决方案"></a>用Java实现死锁，并给出避免死锁的解决方案</h2><h2 id="线程同步和线程调度相关的方法问题"><a href="#线程同步和线程调度相关的方法问题" class="headerlink" title="线程同步和线程调度相关的方法问题"></a>线程同步和线程调度相关的方法问题</h2><h3 id="什么是线程同步？什么是线程互斥？"><a href="#什么是线程同步？什么是线程互斥？" class="headerlink" title="什么是线程同步？什么是线程互斥？"></a>什么是线程同步？什么是线程互斥？</h3><ul>
<li>线程的互斥是指某一个资源只能被一个访问者访问，具有唯一性和排他性。但访问者对资源访问的顺序是乱序的。</li>
<li>线程的同步是在互斥的基础上，访问者的访问顺序是有序的。<h3 id="在Java程序中如何保证线程的运行安全"><a href="#在Java程序中如何保证线程的运行安全" class="headerlink" title="在Java程序中如何保证线程的运行安全"></a>在Java程序中如何保证线程的运行安全</h3></li>
</ul>
<p><strong>线程安全问题主要体现在原子性、可见性和有序性</strong>。</p>
<ul>
<li>原子性：一个或者多个操作在CPU执行的过程中不被中断的特性。线程切换带来的原子性问题。</li>
<li>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。缓存导致的可见性问题。</li>
<li>有序性：程序执行的顺序按照代码的先后顺序执行。编译优化带来的有序性问题。</li>
</ul>
<p>解决方法：</p>
<ul>
<li><p>原子性问题：可用JDK Atomic开头的原子类、 synchronized、 LOCK来解决。</p>
</li>
<li><p>可见性问题：可用synchronized、volatile、 LOCK 来解决。</p>
</li>
<li><p>有序性问题：可用<strong>Happens-Before</strong>规则来解决。</p>
<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><h3 id="synchronized关键字三大特性是什么"><a href="#synchronized关键字三大特性是什么" class="headerlink" title="synchronized关键字三大特性是什么"></a>synchronized关键字三大特性是什么</h3><blockquote>
<p>面试时会将synchronized关键字和volatile关键字进行对比，synchronized关键字可以保证并发编程的三大特性：原子性、可见性和有序性；而volatile关键字只能保证可见性和有序性，称之为轻量级的synchronized。</p>
</blockquote>
</li>
<li><p>原子性：一个或多个操作要么全部执行成功，要么全部执行失败。synchronized关键字可以保证只有一个线程拿到锁，访问共享资源。</p>
</li>
<li><p>可见性：当一个线程对共享变量进行修改后，其他线程可以立刻看到。执行synchronized时， 会对应执行lock、unlock原子操作，保证可见性。</p>
</li>
<li><p>有序性：程序的执行顺序会按照代码的先后顺序执行。</p>
<h3 id="synchronized关键字可以实现什么类型的锁"><a href="#synchronized关键字可以实现什么类型的锁" class="headerlink" title="synchronized关键字可以实现什么类型的锁"></a>synchronized关键字可以实现什么类型的锁</h3></li>
<li><p>悲观锁：synchronized关键字实现的是悲观锁，每次访问共享资源时都会上锁。</p>
</li>
<li><p>非公平锁：synchronized关键字实现的是非公平锁， 即线程获取锁的顺序并不一定是按照线程阻塞的顺序。</p>
</li>
<li><p>可重入锁：synchronized关键字实现的是可重入锁，即已经获取锁的线程可以再次获取锁。</p>
</li>
<li><p>独占锁或者排他锁：synchronized关键字实现的是独占锁，即该锁只能被一个线程所持有，其他线程均被阻塞。</p>
<h3 id="synchronized关键字的使用方式"><a href="#synchronized关键字的使用方式" class="headerlink" title="synchronized关键字的使用方式"></a>synchronized关键字的使用方式</h3><p>主要有三种使用方式：<strong>修饰普通同步方法</strong>、<strong>修饰静态同步方法</strong>、<strong>修饰同步方法块</strong>。</p>
</li>
<li><p>修饰普通同步方法（实例方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 共享资源</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>            add();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">SynTest</span> <span class="hljs-variable">synTest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynTest</span>();<br>        <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(synTest);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(synTest);<br>        <br>        t1.start();<br>        t2.start();<br>        <br>        t1.join();<br>        t2.join();<br>        <br>        System.out.println(i); <span class="hljs-comment">// 2000</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>修饰静态同步方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 共享资源</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>            add();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// SynTest synTest = new SynTest();</span><br>        <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynTest</span>());<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynTest</span>());<br>        <br>        t1.start();<br>        t2.start();<br>        <br>        t1.join();<br>        t2.join();<br>        <br>        System.out.println(i); <span class="hljs-comment">// 2000</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>修饰同步代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 共享资源</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 其他操作</span><br>        <br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// SynTest synTest = new SynTest();</span><br>        <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynTest</span>());<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynTest</span>());<br>        <br>        t1.start();<br>        t2.start();<br>        <br>        t1.join();<br>        t2.join();<br>        <br>        System.out.println(i); <span class="hljs-comment">// 2000</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="synchronized关键字的底层原理"><a href="#synchronized关键字的底层原理" class="headerlink" title="synchronized关键字的底层原理"></a>synchronized关键字的底层原理</h3><p>Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，代码块同步使用的是monitorenter和monitorexit指令实现的，而方法同步是通过Access flags后面的标识来确定该方法是否为同步方法。</p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><h3 id="volatile的作用是什么"><a href="#volatile的作用是什么" class="headerlink" title="volatile的作用是什么"></a>volatile的作用是什么</h3><p>volatile是一个轻量级的synchronized，一般作用于变量，在多处理器开发的过程中保证了内存的可见性。相比于synchronized关键字，其执行成本更低，效率更高。</p>
<h3 id="volatile关键字的特性有哪些"><a href="#volatile关键字的特性有哪些" class="headerlink" title="volatile关键字的特性有哪些"></a>volatile关键字的特性有哪些</h3><blockquote>
<p>并发编程的三大特性为可见性、有序性和原子性。通常来讲volatile可以保证可见性和有序性。</p>
</blockquote>
</li>
<li><p>可见性：volatile可以保证不同线程对共享变量进行操作时的可见性。</p>
</li>
<li><p>有序性：volatile可以通过禁止指令重排序进而保证有序性。</p>
</li>
<li><p>原子性：对于单个的volatile修饰的变量的读写是可以保证原子性的，但对于i++这种复合操作并不能保证原子性。即volatile基本上不具备原子性。</p>
<h3 id="为什么代码会重排序"><a href="#为什么代码会重排序" class="headerlink" title="为什么代码会重排序"></a>为什么代码会重排序</h3><p>计算机在执行程序的过程中，编译器和处理器通常会对指令进行重排序，这样做的目的是为了提高性能。<br>指令重排序一般分为<strong>编译器优化重排</strong>、<strong>指令并行重排</strong>和<strong>内存系统重排。</strong></p>
</li>
<li><p>编译器优化重排：编译器在不改变单线程程序语义的情况下，可以对语句的执行顺序进行重排序。</p>
</li>
<li><p>指令并行重排：现代处理器多采用指令级并行技术来将多条指令重叠执行。对于不存在<strong>数据依赖</strong>的程序，处理器可以对机器指令的执行顺序进行重新排列。</p>
</li>
<li><p>内存系统重排：因为处理器使用缓存和读/写缓冲区，使得加载（load）和存储（store）看上去像是在乱序执行。</p>
<h3 id="重排序会引发什么问题"><a href="#重排序会引发什么问题" class="headerlink" title="重排序会引发什么问题"></a>重排序会引发什么问题</h3><p>在多线程代码中，重排序会破坏多线程程序的语义。</p>
<h3 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h3></li>
<li><p>volatile主要是保证内存的可见性，即变量在寄存器中的内存是不确定的，需要从主存中读取。synchronized主要是解决多个线程访问资源的同步性。</p>
</li>
<li><p>volatile作用于变量，synchronized作用于代码块或者方法。</p>
</li>
<li><p>volatile仅可以保证数据的可见性，不能保证数据的原子性。synchronized可以保证数据的可见性和原子性。</p>
</li>
<li><p>volatile不会造成线程的阻塞，synchronized会造成线程的阻塞。</p>
<h2 id="CurrentHashMap"><a href="#CurrentHashMap" class="headerlink" title="CurrentHashMap"></a>CurrentHashMap</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1659337132321-2133429a-8a3e-429b-aff6-c6a4d7843a8e.png#clientId=u1e77df9b-6dc6-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=301&id=u52932632&margin=%5Bobject%20Object%5D&name=image.png&originHeight=301&originWidth=506&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10148&status=done&style=none&taskId=u36bff6c3-ccd4-4c5f-8477-83c66cf7924&title=&width=506" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="什么是CurrentHashMap？相比于HashMap和HashTable有什么优势？"><a href="#什么是CurrentHashMap？相比于HashMap和HashTable有什么优势？" class="headerlink" title="什么是CurrentHashMap？相比于HashMap和HashTable有什么优势？"></a>什么是CurrentHashMap？相比于HashMap和HashTable有什么优势？</h3><p>CocurrentHashMap可以看作_<strong>线程安全</strong>_且高效的HashMap，相比于HashMap具有线程安全的优势，相比于HashTable具有效率高的优势。</p>
<h3 id="Java中CurrentHashMap是如何实现的"><a href="#Java中CurrentHashMap是如何实现的" class="headerlink" title="Java中CurrentHashMap是如何实现的"></a>Java中CurrentHashMap是如何实现的</h3><blockquote>
<p>注意：JDK 1.7和JDK1.8中的实现存在差异。</p>
</blockquote>
</li>
<li><p>JDK 1.7</p>
</li>
</ul>
<p>在JDK1.7版本中，ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry数组组成，Segment存储的是链表数组的形式，如图所示。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658906869689-c522e379-464d-4fac-8b8d-bc5b89cbce48.png#clientId=u45035bbf-2508-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=785&id=u843e5c79&margin=%5Bobject%20Object%5D&name=image.png&originHeight=785&originWidth=1161&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49283&status=done&style=none&taskId=u9cd1823b-675c-4e8e-8957-7545af12ff2&title=&width=1161" srcset="/img/loading.gif" lazyload alt="image.png"><br>从上图可以看出，ConcurrentHashMap定位一个元素的过程需要两次hash的过程，第一次hash的目的是定位到Segment，第二次hash的目的是定位到链表的头部。两次hash所使用的时间比一次hash的时间要长，但这样做可以在写操作时，只对元素所在的Segment加锁，不会影响到其他Segment，这样可以大大提高并发能力。</p>
<ul>
<li>JDK 1.8</li>
</ul>
<p>JDK1.8不在采用Segment的结构，而是使用Node数组+链表/红黑树的数据结构来实现的(和HashMap一样，<strong>链表节点个数大于8，或Node数组大于64时，链表会转换为红黑树</strong>)。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658907006317-7bafc8ec-6733-44c8-a83f-3638975ac3cf.png#clientId=u45035bbf-2508-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=720&id=u66517a2e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=720&originWidth=1083&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111411&status=done&style=none&taskId=u8f960b47-9d57-49ec-83c0-5a5ca5c5623&title=&width=1083" srcset="/img/loading.gif" lazyload alt="image.png"><br>从上图可以看出，对于ConcurrentHashMap的实现，JDK1.8的实现方式可以<strong>降低锁的粒度</strong>，因为JDK1.7所实现的ConcurrentHashMap的锁的粒度是基于Segment，而一个Segment包含多个HashEntry。</p>
<h3 id="ConcurrentHashMap初始容量和扩容"><a href="#ConcurrentHashMap初始容量和扩容" class="headerlink" title="ConcurrentHashMap初始容量和扩容"></a>ConcurrentHashMap初始容量和扩容</h3><ul>
<li>初始容量为16</li>
<li>每次扩容为之前的两倍<h3 id="键值是否可以为空"><a href="#键值是否可以为空" class="headerlink" title="键值是否可以为空"></a>键值是否可以为空</h3>ConcurrentHashMap中的key和value均不可以为null，如果插入数据时只要有一个为空则会报空指针异常。这一点与HashMap不同。</li>
</ul>
<p><strong>原因如下</strong>：ConcurrentHashMap是在多线程场景下使用的，如果ConcurrentHashMap.get(key)的值为null，那么无法判断到底是key对应的value的值为null还是不存在对应的key值。而在单线程场景下的HashMap中，可以使用containsKey(key)来判断到底是不存在这个key还是key对应的value的值为null。在多线程的情况下使用containsKey(key)来做这个判断是存在问题的，因为在containsKey(key)和ConcurrentHashMap.get(key)两次调用的过程中，key的值经发生了改变。</p>
<h3 id="ConcurrentHashMap适用场景"><a href="#ConcurrentHashMap适用场景" class="headerlink" title="ConcurrentHashMap适用场景"></a>ConcurrentHashMap适用场景</h3><p>用于并发场景下，更进一步可以用在创建普通POJO对象的场景中，JVM的GC会自动回收无效的引用；不适合保存创建计算机资源（如线程池、IO等）的场景，因为这些资源是有限的。<br>例子：<br>用于保存在线用户</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在线用户管理类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserManager</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;String, User&gt; userMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-comment">// 当用户登入时调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUserSignIn</span><span class="hljs-params">(String sessionId, User user)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userMap.put(sessionId, user);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 当用户登出或超时时调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUserSignOut</span><span class="hljs-params">(String sessionId)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userMap.remove(sessionId);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">getUser</span><span class="hljs-params">(String sessionId)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.userMap.get(sessionId);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当有很多用户同时登入和登出时，两个方法就会有很多线程同时调用。</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal"></a>什么是ThreadLocal</h3><p>ThreadLocal是JDK中java.lang包下的一个类，ThreadLocal 为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量，并且不会和其他线程的局部变量冲突，实现了线程间的数据隔离。<br>总结就是ThreadLocal是一个关于创建线程局部变量的类。<br>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。</p>
<h3 id="ThreadLocal的应用场景"><a href="#ThreadLocal的应用场景" class="headerlink" title="ThreadLocal的应用场景"></a>ThreadLocal的应用场景</h3><ul>
<li>保存线程上下文信息，在需要的地方可以获取</li>
<li>线程间数据隔离</li>
<li>数据库连接<h3 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h3><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1659427849422-4f9f3496-d301-4c94-8176-496ff8503ff9.png#clientId=ud96b3449-5125-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=527&id=u0ff5fe23&margin=%5Bobject%20Object%5D&name=image.png&originHeight=527&originWidth=829&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66942&status=done&style=none&taskId=u669ee662-1769-4356-9045-a2cb56f9833&title=&width=829" srcset="/img/loading.gif" lazyload alt="image.png"><br>每个线程Thread都有一个ThreadLocalMap，ThreadLocalMap中保存着所有的ThreadLocal，是真正承载数据的一个Entry数组，Entry的key是ThreadLocal对象的<strong>弱引用</strong>。即ThreadLocal的值时放入了一当前线程的一个ThreadLocalMap实例中。故只能在本线程中访问，其他线程无法访问。<blockquote>
<p>补充：弱引用一般是用来描述非必需对象的，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。<strong>当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</strong>。</p>
</blockquote>
</li>
</ul>
<h3 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h3><p>结论是使用不当会造成内存泄漏。ThreadLocalMap中对ThreadLocal对象的引用被设计为弱引用，就是防止在ThreadLocal对象在栈中被清除后而在堆中的对象发生内存泄漏。即使设计成这样，依然可能发生内存泄漏，如线程不被回收。什么情况下有可能会发生线程不被回收呢？在线程池中，由于线程每次使用完之后会放回线程池，由于线程没有被销毁，所以值一直存在，这样就发生了内存泄漏。</p>
<h3 id="内存泄漏解决办法"><a href="#内存泄漏解决办法" class="headerlink" title="内存泄漏解决办法"></a>内存泄漏解决办法</h3><p>其实ThreadLocal在设计的时候已经考虑到了这种情况，在调用set()、get()、 remove() 等方法时就会清理掉key为null的记录，所以在使用完ThreadLocal后最好手动调用remove()方法。</p>
<h3 id="为什么要将ThreadLocalMap中的key设计成ThreadLocal的弱引用"><a href="#为什么要将ThreadLocalMap中的key设计成ThreadLocal的弱引用" class="headerlink" title="为什么要将ThreadLocalMap中的key设计成ThreadLocal的弱引用"></a>为什么要将ThreadLocalMap中的key设计成ThreadLocal的弱引用</h3><p>如果ThreadLocalMap的key是强引用，同样会发生内存泄漏的。如果ThreadLocalMap的key是强引用，引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，发生内存泄漏。<br>如果是弱引用的话，引用的ThreadLocal的对象被回收了，即使没有手动删除，ThreadLocal也会被<br>回收。value也会在ThreadLocalMap调用set()、get()、 remove() 的时候会被清除。<br>所以两种方案比较下来，还是ThreadLoaclMap的key为弱引用好些。</p>
<hr>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="HotSpot虚拟机"><a href="#HotSpot虚拟机" class="headerlink" title="HotSpot虚拟机"></a>HotSpot虚拟机</h2><h3 id="创建对象时内存的分配方式"><a href="#创建对象时内存的分配方式" class="headerlink" title="创建对象时内存的分配方式"></a>创建对象时内存的分配方式</h3><p>创建对象时根据Java内存是否完整，分配方式有<strong>指针碰撞（完整）</strong>和<strong>空闲列表（不完整）</strong>。<br><strong>（1）指针碰撞</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657075232431-2957e6e2-f6fb-46c9-b7e7-0f6116bf1f58.png#clientId=ucd4d0f03-b44f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=295&id=uadf0d605&margin=%5Bobject%20Object%5D&name=image.png&originHeight=295&originWidth=998&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29364&status=done&style=none&taskId=u2b63b606-ec86-49ec-9e4d-c60527200fb&title=&width=998" srcset="/img/loading.gif" lazyload alt="image.png"><br><strong>注：</strong>选择哪种分配方式由Java堆是否完整决定，Java堆是否完整由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头、实例数据、对齐填充。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657078043672-b407d9b2-2ea3-4581-a935-16207d307e75.png#clientId=uef0d43a0-2438-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc1987776&margin=%5Bobject%20Object%5D&originHeight=268&originWidth=223&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u492f9c3c-35ff-40f6-b493-f915e7e1d44&title=" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p><strong>对象头（Object Header）</strong>：包含两部分信息，一部分用于存储自身的运行时数据，如哈希码、GC分带年龄、锁状态标志、线程持有的锁、偏向线程ID等；另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过该指针来确定这个对象是哪个类的实例。</p>
</li>
<li><p><strong>实例数据（Instance Data）</strong>：对象真正存储的有效信息，也是代码中所定义的各种类型的字段内容。</p>
</li>
<li><p><strong>对齐填充（Padding）</strong>：为了字节填充，填充的数据，不是必须的。</p>
<h3 id="对象的访问方式"><a href="#对象的访问方式" class="headerlink" title="对象的访问方式"></a>对象的访问方式</h3><p>Java程序通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式有使用<strong>句柄</strong>和<strong>直接指针</strong>。</p>
</li>
<li><p><strong>句柄：</strong>Java堆中会划分出一块内存来作为句柄，reference中存储的是对象的句柄地址， 而句柄中包含了对象实例数据与类型数据各自的具体地址信息。通过使用句柄访问对象，reference中存储的是稳定的句柄地址，在对象移动时（垃圾回收时会经常移动对象）只会改变句柄中的实例数据指针，无需改变reference。</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657094320326-950c7c8e-c2da-4a52-847d-8efb787f5e1c.png#clientId=uef0d43a0-2438-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=574&id=udf0cbdbd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=574&originWidth=1120&originalType=binary&ratio=1&rotation=0&showTitle=false&size=232096&status=done&style=none&taskId=u8801258c-0eb5-4a5f-9779-b275f64f9cd&title=&width=1120" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li><strong>直接指针</strong>：使用直接指针访问对象，reference中存储的是对象地址，而Java堆中对象的布局需要考虑如何放置访问类型数据的相关信息。使用直接指针访问对象省了一次指针定位的时间开销，速度更快。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657094576572-a8bb76ab-a6dc-4e45-bd47-f18bce9702a9.png#clientId=uef0d43a0-2438-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=558&id=ub108f54e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=558&originWidth=1125&originalType=binary&ratio=1&rotation=0&showTitle=false&size=199935&status=done&style=none&taskId=u9f236c2f-1274-4ac2-8489-2ba68cf66a2&title=&width=1125" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="Java内存泄漏"><a href="#Java内存泄漏" class="headerlink" title="Java内存泄漏"></a>Java内存泄漏</h2><h3 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h3><p>内存泄漏指对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为在被引用着。<br>在Java中，<strong>内存泄漏</strong>就是存在一些被分配的对象，这些对象有下面两个特点：</p>
<ul>
<li><strong>首先</strong>，这些对象是可达的，即<strong>在有向图中，存在通路可以与其相连</strong>；</li>
<li><strong>其次</strong>，<strong>这些对象是无用的，即程序以后不会再使用这些对象</strong>。</li>
</ul>
<p>如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。<br>简单来说就是申请内存使用完了不进行释放。</p>
<h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><ul>
<li><p><strong>静态集合类引起内存泄漏</strong>，因为静态集合的生命周期与JVM一致，所以静态集合引用的对象不能被释放。</p>
</li>
<li><p><strong>单例模式导致内存泄漏</strong>，因为单例模式的静态特性，它的生命周期和JVM的生命周期一致，如果单例对象持有外部对象的引用，这个对象也不会被回收。</p>
</li>
<li><p><strong>内部类的对象被长期持有</strong>，那么内部类对象所属的外部类对象不能被回收。</p>
</li>
<li><p><strong>数据库连接、网络连接等各种连接没有显式释放导致内存泄漏</strong>。</p>
</li>
<li><p><strong>改变哈希值</strong>，例如在一个对象存储到HashSet后，改变了对象中参与计算哈希值的字段，那么会导致对象的哈希值发生变化，和之前存入HashSet的哈希值不同，也就无法通过当前对象的引|用在HashSet中找到这个对象，无法从HashSet中删除对象，造成内存泄漏，这也是为什么通常利用String类型的变量当作HashMap的key,因为String类型是不可变的。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>写代码时尽量避免上述会造成内存泄漏的情况。</p>
<h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><h3 id="什么是内存溢出"><a href="#什么是内存溢出" class="headerlink" title="什么是内存溢出"></a>什么是内存溢出</h3><p>指程序运行过程中无法申请到足够的内存导致的错误。</p>
<h3 id="产生原因-1"><a href="#产生原因-1" class="headerlink" title="产生原因"></a>产生原因</h3></li>
<li><p>内存加载的数据量太大，内存不够用了</p>
</li>
<li><p>代码中存在死循环或循环产生大量对象</p>
</li>
<li><p>启动参数内存值设置过小</p>
</li>
<li><p>长期的内存泄漏也会导致内存溢出</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3></li>
<li><p>修改<strong>JVM启动参数</strong>，增加内存</p>
</li>
<li><p>使用<strong>内存查看工具</strong>动态查看内存使用情况</p>
</li>
<li><p>对代码进行排查，重点排查有没有上述提到的造成常见内存溢出情景的代码</p>
<h2 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h2><p>当线程所请求的栈深度超过虚拟机所允许的最大深度后，会发生栈溢出，即<code>StackOverflowError</code> ,比如在方法递归调用时就可能发生栈内存溢出，可以通过<strong>JVM参数-Xss</strong>来调整栈内存的大小来避免栈内存溢出，但如果是代码问题光调整栈内存大小肯定是不够的，还是要从根本解决问题。</p>
<h2 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h2><h3 id="如何判断对象是否可以回收"><a href="#如何判断对象是否可以回收" class="headerlink" title="如何判断对象是否可以回收"></a>如何判断对象是否可以回收</h3><p>判断对象是否死亡的常见方法主要有<strong>引用计数法</strong>和<strong>可达性分析法</strong>两种。</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器就会加1；当引用失效时，计数器就减1，当计数器为0就是没有被使用的对象，但主流的Java虚拟机并没有选择用弓|用计数法来管理内存，因为无法解决对象之间相互循环引用的问题，就是两个对象相互引用，除此之外，两个对象并没有其他引用，这两个对象已经不可能被访问了，但他们的弓|用计数都不为0，所以无法被垃圾收集器回收。</p>
<h4 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h4><p>可达性分析法就是通过一系列被称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径被称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明该对象是不可用的，也就是可回收的，如下图，对象object 5、object 6、object 7虽然有关联，但他们到GC Roots是不可达的，所以也会判定是可以回收的，这样解决了对象之间相互引用导致不能回收的问题。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657267387921-d1f582e0-0be8-4736-9a13-39c78503755a.png#clientId=udfed2b78-8c5f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=653&id=u1dd1d734&margin=%5Bobject%20Object%5D&name=image.png&originHeight=653&originWidth=1156&originalType=binary&ratio=1&rotation=0&showTitle=false&size=291421&status=done&style=none&taskId=u33dc7fb4-4ca9-4f30-b2ba-528109f8135&title=&width=1156" srcset="/img/loading.gif" lazyload alt="image.png"></p>
</li>
</ul>
<p><strong>注：</strong>在Java语言中，可以作为GC Roots的对象主要有以下几种：</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的属性</li>
<li>本地方法栈中Native中引用的对象<h3 id="JVM中的方法区（永久代）会发生垃圾回收吗？元空间会发生垃圾回收吗？"><a href="#JVM中的方法区（永久代）会发生垃圾回收吗？元空间会发生垃圾回收吗？" class="headerlink" title="JVM中的方法区（永久代）会发生垃圾回收吗？元空间会发生垃圾回收吗？"></a>JVM中的方法区（永久代）会发生垃圾回收吗？元空间会发生垃圾回收吗？</h3></li>
</ul>
<ol>
<li>永久代概念是HotSpot虚拟机独有</li>
<li>JDK1.8之前JVM存在永久代，JDK1.8被元空间替代；永久代和元空间都是方法区的具体实现，方法区只是一个规范。</li>
<li>在永久代中发生的内存回收主要是<strong>常量池的回收</strong>和<strong>类型的卸载</strong>。</li>
<li>判断一个类型是否可以回收需要看以下方面：</li>
</ol>
<ul>
<li>该类型所有实例都被回收</li>
<li>加载该类的类加载器已经被回收</li>
<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<ol start="5">
<li>在JDK1.8中使用元空间取代永久代，主要是因为：永久代使用的是设定好的虚拟机内存，无法动态扩展内存空间，当加载过多的类时可能发生OOM，并且永久代的内存大小设置也是难以确定的，所以对永久代的调优比较困难；而元空间的出现是为了解决永久代的问题，因为元空间不再使用虚拟机的内存，而是使用本地内存，本地内存可以自动扩展调节，内存不足也不会出发Full GC。<h3 id="主动通知虚拟机进行垃圾回收"><a href="#主动通知虚拟机进行垃圾回收" class="headerlink" title="主动通知虚拟机进行垃圾回收"></a>主动通知虚拟机进行垃圾回收</h3>可以通过调用<code>System.gc()</code>方法通知虚拟机进行垃圾回收，但Java虚拟机规范并不能保证一定会执行。<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3></li>
</ol>
<ul>
<li><p>标记——清除算法</p>
</li>
<li><p>标记——复制算法</p>
</li>
<li><p>标记——整理算法</p>
</li>
<li><p>分代收集算法</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>垃圾回收算法是内存回收的方法论，垃圾收集器则是内存回收的具体实现。Java规范中并没有对垃圾收集器的实现有任何规范，所以不用的厂商、不同的版本的虚拟机提供的垃圾收集器是不同的。</p>
<h2 id="关于类加载"><a href="#关于类加载" class="headerlink" title="关于类加载"></a>关于类加载</h2><p>类加载机制：虚拟机把类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p>
<h3 id="简述类的生命周期"><a href="#简述类的生命周期" class="headerlink" title="简述类的生命周期"></a>简述类的生命周期</h3><p>类从被加载到虚拟机内存中开始，到卸载为止，生命周期包括：<strong>加载、验证、准备、解析、初始化、使用和卸载</strong>。其中验证、准备和解析统称为连接。</p>
<h3 id="简述类的加载过程"><a href="#简述类的加载过程" class="headerlink" title="简述类的加载过程"></a>简述类的加载过程</h3><p>类的加载过程也就是类的生命周期的前五部分，加载、验证、准备、解析和初始化。</p>
<h3 id="类加载器有哪些"><a href="#类加载器有哪些" class="headerlink" title="类加载器有哪些"></a>类加载器有哪些</h3><p>类加载器的作用就是将类加载到虚拟机的内存中。<br>JVM主要提供三个类加载器：</p>
</li>
<li><p>启动类加载器（Bootstrap ClassLoader）</p>
</li>
<li><p>扩展类加载器（Extension ClassLoader）</p>
</li>
<li><p>应用程序类加载器（Application ClassLoader）</p>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>双亲委派机制是指如果一个类加载器收到 了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是这样，所以所有的加载请求最终都应该传送到顶层的启动类加载容器，只有当父类加载器无法完成加载时，子加载器才会尝试自己去加载，如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657678603571-2ff051ea-bf2e-4847-ace4-25a194174627.png#clientId=u005da07f-0361-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=537&id=ue188f49b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=790&originWidth=798&originalType=binary&ratio=1&rotation=0&showTitle=false&size=422313&status=done&style=none&taskId=ud973c139-0ea8-48a8-945c-1f0557874e9&title=&width=542" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="JVM调优相关"><a href="#JVM调优相关" class="headerlink" title="JVM调优相关"></a>JVM调优相关</h2><h3 id="JVM调优的目标"><a href="#JVM调优的目标" class="headerlink" title="JVM调优的目标"></a>JVM调优的目标</h3><p>大多数时候，JVM调优最主要的目标是<strong>停顿时间</strong>和<strong>吞吐量</strong>，还有一个指标是<strong>内存占用</strong>。</p>
<h3 id="JVM调优策略"><a href="#JVM调优策略" class="headerlink" title="JVM调优策略"></a>JVM调优策略</h3><p>JVM调优的具体策略基本都是围绕两部分展开的，即<strong>内存</strong>和<strong>垃圾回收器</strong>。</p>
<h3 id="JVM调优步骤"><a href="#JVM调优步骤" class="headerlink" title="JVM调优步骤"></a>JVM调优步骤</h3><p>JVM调优应先确定瓶颈及调优目标，如下：</p>
</li>
<li><p>分析GC日志及通过虚拟机监控的命令查看系统运行情况，找出哪里出了问题</p>
</li>
<li><p>确定调优的目标</p>
</li>
<li><p>确定调优策略及调整相关参数，这是个不断对比分析和调整的过程，很难一步到位</p>
</li>
</ul>
<hr>
<h1 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h1><h2 id="MySQL常用的存储引擎以及区别"><a href="#MySQL常用的存储引擎以及区别" class="headerlink" title="MySQL常用的存储引擎以及区别"></a>MySQL常用的存储引擎以及区别</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB是MySQL的默认存储引擎，支持事务、行锁和外键等操作。</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM是MySQL5.1版本前的默认存储引擎，MyISAM的并发性比较差，不支持事务和外键等操作，默认的锁的粒度为表级锁。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table>
<thead>
<tr>
<th></th>
<th><strong>InnoDB</strong></th>
<th><strong>MyISAM</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>外键</strong></td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>事务</strong></td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>锁</strong></td>
<td>支持表锁和行锁</td>
<td>支持表锁</td>
</tr>
<tr>
<td><strong>可恢复性</strong></td>
<td>根据事务日志进行恢复</td>
<td>无事务日志</td>
</tr>
<tr>
<td><strong>表结构</strong></td>
<td>数据和索引是集中存储的，文件格式分别为<code>.ibd</code>和<code>.frm</code></td>
<td>数据和索引是分开存储的，数据是<code>.MYD</code>，索引是<code>.MYI</code></td>
</tr>
<tr>
<td><strong>查询性能</strong></td>
<td>一般情况相比于MyISAM较差</td>
<td>一般情况相比于InnoDB好些</td>
</tr>
<tr>
<td><strong>索引</strong></td>
<td>聚簇索引</td>
<td>非聚簇索引</td>
</tr>
</tbody></table>
<h2 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h2><ul>
<li>第一范式：确保每列保持原子性， 数据表中的所有字段值都是不可分解的原子值。</li>
<li>第二范式：确保表中的每列都和主键相关。</li>
<li>第三范式：确保每列都和主键列直接相关而不是间接相关。<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3>数据库索引是排好序的数据结构，具体是对数据库表的一列或者多列的值进行排序的一种结构。<h3 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h3>索引的一个主要目的就是加快检索表中数据，实现快速访问数据表中的特定信息。<h3 id="什么是最左前缀匹配原则"><a href="#什么是最左前缀匹配原则" class="headerlink" title="什么是最左前缀匹配原则"></a>什么是最左前缀匹配原则</h3>MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。<strong>而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。</strong><br>这里举个例子，如User表的name和city组合为联合索引就是(name, city)。有如下查询语句，后跟索引命中情况：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span>xx <span class="hljs-keyword">and</span> city<span class="hljs-operator">=</span>yy; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 可以命中索引，原因是查询条件匹配索引的最左边列<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span>xx; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 命中索引<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> city<span class="hljs-operator">=</span>yy; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 无法命中索引，原因是索引最左边列未在查询条件中<br></code></pre></td></tr></table></figure>
需要补充的是，查询的时候如果索引列的条件均用上，但最左边索引在查询条件中不在第一列时也能命中索引，原因是现在的查询引擎会自动优化为匹配联合索引的顺序。<br>另外，总结就是最左匹配原则是从最左边为起点开始连续匹配，遇到范围查询(&lt;、&gt;、between、like)会停止匹配。</li>
</ul>
<h2 id="数据库的事务"><a href="#数据库的事务" class="headerlink" title="数据库的事务"></a>数据库的事务</h2><h3 id="什么是数据库的事务"><a href="#什么是数据库的事务" class="headerlink" title="什么是数据库的事务"></a>什么是数据库的事务</h3><p><strong>数据库事务( transaction)<strong>是访问并可能操作各种数据项的一个</strong>数据库操作序列</strong>，<strong>这些操作要么全部执行，要么全部不执行</strong>，是一个<strong>不可分割</strong>的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。</p>
<h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><p>事务的四大特性即通常所说的ACID(Atomicity原子性、Consistency一致性、Isolation隔离性、Durability持久性)。</p>
<ul>
<li><p><strong>原子性</strong>：原子性是指包含事务的操作要么全部执行成功，要么全部失败回滚。</p>
</li>
<li><p><strong>一致性</strong>：一致性指事务在执行前后状态是一致的。</p>
</li>
<li><p><strong>隔离性</strong>：一个事务所进行的修改在最终提交之前，对其他事务是不可见的。</p>
</li>
<li><p><strong>持久性</strong>：数据一旦提交，其所作的修改将永久地保存到数据库中。</p>
<h3 id="数据库的并发一致性问题"><a href="#数据库的并发一致性问题" class="headerlink" title="数据库的并发一致性问题"></a>数据库的并发一致性问题</h3><p>当多个事务并发执行时，可能会出现以下问题：</p>
</li>
<li><p><strong>脏读</strong>：事务A更新了数据，但还没有提交，这时事务B读取到事务A更新后的数据，然后事务A回滚了，事务B读取到的数据就成为脏数据了。</p>
</li>
<li><p><strong>不可重复读</strong>：事务A对数据进行多次读取，事务B在事务A多次读取的过程中执行了更新操作并提交了，导致事务A多次读取到的数据并不一致。</p>
</li>
<li><p><strong>幻读</strong>：事务A在读取数据后，事务B向事务A读取的数据中插入了几条数据，事务A再次读取数据时发现多了几条数据，和之前读取的数据不一致。</p>
</li>
<li><p><strong>丢失修改</strong>：事务A和事务B都对同一个数据进行修改，事务A先修改，事务B随后修改，事务B的修改覆盖了事务A的修改。</p>
</li>
</ul>
<p><strong>不可重复读</strong>和<strong>幻读</strong>看起来比较像，它们主要的区别是：在<strong>不可重复读</strong>中，发现数据不一致主要是数据被更新了。在<strong>幻读</strong>中，发现数据不一致主要是数据增多或者减少了。</p>
<h3 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h3><p>较低级别的隔离通常可以执行更高的并发，系统的开销也越低。下列隔离级别由低到高。</p>
<ul>
<li>**未提交读(READ UNCOMMITTED)**：一个事务在提交前，它的修改对其他事务也是可见的。</li>
<li>**提交读(READ COMMITTED)**：一个事务提交之后，它的修改才能被其他事务看到。</li>
<li>**可重复读(REPEATABLE READ)**：在同一个事务中多次读取到的数据是一致的。</li>
<li>**串行化(SERIALIZABLE)**：需要加锁实现，会强制事务串行执行。</li>
</ul>
<p>数据库的隔离级别分别可以解决数据库的脏读、不可重复读、幻读等问题。</p>
<table>
<thead>
<tr>
<th><strong>隔离级别</strong></th>
<th><strong>脏读</strong></th>
<th><strong>不可重复读</strong></th>
<th><strong>幻读</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>未提交读</strong></em></td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td><em><strong>提交读</strong></em></td>
<td>不允许</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td><em><strong>可重复读</strong></em></td>
<td>不允许</td>
<td>不允许</td>
<td>允许</td>
</tr>
<tr>
<td><em><strong>串行化</strong></em></td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
</tr>
</tbody></table>
<p><strong>MySQL的默认隔离级别是可重复读。</strong></p>
<h3 id="隔离级别是如何实现的"><a href="#隔离级别是如何实现的" class="headerlink" title="隔离级别是如何实现的"></a>隔离级别是如何实现的</h3><p>事务的隔离机制主要是依靠锁机制和MVCC(多版本并发控制)实现的，提交读和可重复读可以通过MVCC实现，串行化可以通过锁机制实现。</p>
<h2 id="数据库的锁"><a href="#数据库的锁" class="headerlink" title="数据库的锁"></a>数据库的锁</h2><h3 id="什么是数据库的锁"><a href="#什么是数据库的锁" class="headerlink" title="什么是数据库的锁"></a>什么是数据库的锁</h3><p>当数据库有并发事务的时候，保证数据访问顺序的机制称为锁机制。</p>
<h3 id="数据库的锁与隔离级别的关系"><a href="#数据库的锁与隔离级别的关系" class="headerlink" title="数据库的锁与隔离级别的关系"></a>数据库的锁与隔离级别的关系</h3><table>
<thead>
<tr>
<th><strong>隔离级别</strong></th>
<th><strong>实现方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>未提交读</td>
<td>最低级别的隔离特性，无需加锁</td>
</tr>
<tr>
<td>提交读</td>
<td>读取数据时加共享锁，读取数据后释放共享锁</td>
</tr>
<tr>
<td>可重复读</td>
<td>读取数据时加共享锁，事务结束后释放共享锁</td>
</tr>
<tr>
<td>串行化</td>
<td>锁定整个范围的键，一直持有锁直到事务结束</td>
</tr>
</tbody></table>
<h3 id="数据库锁的类型有哪些"><a href="#数据库锁的类型有哪些" class="headerlink" title="数据库锁的类型有哪些"></a>数据库锁的类型有哪些</h3><p>按照锁的粒度，MySQL主要有以下类别的锁，各自的特点如表所示：</p>
<table>
<thead>
<tr>
<th><strong>锁类别</strong></th>
<th><strong>资源开销</strong></th>
<th><strong>加锁速度</strong></th>
<th><strong>是否会出现死锁</strong></th>
<th><strong>锁的粒度</strong></th>
<th><strong>并发度</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>表级锁</strong></td>
<td>小</td>
<td>快</td>
<td>不会</td>
<td>大</td>
<td>低</td>
</tr>
<tr>
<td><strong>行级锁</strong></td>
<td>大</td>
<td>慢</td>
<td>会</td>
<td>小</td>
<td>高</td>
</tr>
</tbody></table>
<p>拓展：</p>
<ol>
<li>表级锁会在加锁时获取到全部的锁，要么全部满足，要么等待，所以不会产生死锁；InnoDB存储引擎中，锁都是逐步获得的，所以会存在死锁问题。</li>
<li>行级锁由于不合理的加锁顺序，可能会产生死锁。</li>
<li>MyISAM默认也仅支持表级锁；InnoDB默认采用行级锁。</li>
</ol>
<p>从锁的类别上可以将锁分为共享锁和排它锁：</p>
<ul>
<li>共享锁：共享锁又称读锁，简写为S锁，一个事务对一个数据对象加了S锁，可以对这个数据对象进行读取操作，但不能进行更新操作。并且在加锁期间其他事务只能对这个数据对象加S锁，不能加X锁。</li>
<li>排他锁：排他锁又称为写锁，简写为X锁，一个事务对一个数据对象加了X锁，可以对这个对象进行读取和更新操作，加锁期间，其他事务不能对该数据对象进行加X锁或S锁。<h2 id="数据库的优化"><a href="#数据库的优化" class="headerlink" title="数据库的优化"></a>数据库的优化</h2><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3>见博客：<a href="https://miderl.github.io/2022/07/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/">数据库的分库分表</a></li>
</ul>
<hr>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring基础概念"><a href="#Spring基础概念" class="headerlink" title="Spring基础概念"></a>Spring基础概念</h2><h3 id="Spring框架中都用到了哪些设计模式"><a href="#Spring框架中都用到了哪些设计模式" class="headerlink" title="Spring框架中都用到了哪些设计模式"></a>Spring框架中都用到了哪些设计模式</h3><p>Spring框架中使用了大量的设计模式，如下：</p>
<ul>
<li>代理模式（Proxy）——在AOP中用的比较多</li>
<li>单例模式（Singleton）——在Spring配置文件中定义的Bean默认为单例模式</li>
<li>工厂模式——BeanFactory用来创建对象的实例</li>
<li>模板方法模式——用来解决代码重复的问题，如RestTemplate、JmsTemplate、JpaTemplate等</li>
<li>前端控制器——Spring提供了DispatcherServlet来对请求进行分发</li>
<li>适配器模式——Spring AOP的Advice中使用到了适配器模式，以及Spring MVC中适配Controller时也用到了适配器模式</li>
<li>观察者模式——Spring事件驱动模型</li>
<li>装饰者模式——当项目需要连接多个数据库，不同的客户根据需要去访问不同的数据库，装饰者模式可以根据客户的需求动态切换不同的数据源<h2 id="Spring控制反转-IoC"><a href="#Spring控制反转-IoC" class="headerlink" title="Spring控制反转(IoC)"></a>Spring控制反转(IoC)</h2><h3 id="什么是Spring-IoC容器"><a href="#什么是Spring-IoC容器" class="headerlink" title="什么是Spring IoC容器"></a>什么是Spring IoC容器</h3></li>
</ul>
<ol>
<li>简单说就是将创建对象的控制权交给Spring框架。（从程序中剥离）</li>
<li>IoC是一种思想，主要优点有两个：</li>
</ol>
<ul>
<li>降低代码之间的耦合度</li>
<li>集中资源统一管理，简化开发</li>
</ul>
<ol start="3">
<li><p>IoC还有一种说法是DI(Dependency Injection)，即依赖注入。两者更进一步的关系，可以被描述为IoC是一种思想，而DI是IoC的一种实现方式。</p>
<h3 id="Spring-IoC的实现机制"><a href="#Spring-IoC的实现机制" class="headerlink" title="Spring IoC的实现机制"></a>Spring IoC的实现机制</h3><p>简单来说就是通过解析XML文件获取到对象信息，通过反射获取字节码文件，然后通过字节码文件创建对象，并且在创建对象的过程中使用了工厂模式。</p>
<h3 id="BeanFactory和ApplicationContext有什么区别"><a href="#BeanFactory和ApplicationContext有什么区别" class="headerlink" title="BeanFactory和ApplicationContext有什么区别"></a>BeanFactory和ApplicationContext有什么区别</h3><p><code>BeanFactory</code>和<code>ApplicationContext</code>是Spring的两大核心接口，都可以当做Spring的容器。它们之间是派生关系，类图如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657444407108-37d950db-1abe-4d12-af32-8ae4c1967775.png#clientId=u48d5a21b-2cf2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=297&id=u15211376&margin=%5Bobject%20Object%5D&name=image.png&originHeight=297&originWidth=1380&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18697&status=done&style=none&taskId=ua62f516f-affe-4e1b-a4c5-fbb2ace0f5c&title=&width=1380" srcset="/img/loading.gif" lazyload alt="image.png"><br>两者之间的区别有：</p>
</li>
<li><p><strong>作用</strong></p>
</li>
</ol>
<p><code>BeanFactory</code>接口作用：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。<br><code>ApplicationContext</code>接作用：<code>ApplicationContext</code>接口作为<code>BeanFactory</code>的派生， 除了提供<code>BeanFactory</code>所具有的功能外，还有额外的功能：</p>
<ul>
<li>提供在监听器中注册bean的事件</li>
<li>载入多个(有继承关系)上下文,使得每一个上下文都专注于一个特定的层次，比如应用的web层</li>
<li>同时加载多个配置文件</li>
<li>统一的资源文件访问方式</li>
<li>继承<code>MessageSource</code>，因此支持国际化</li>
</ul>
<ol start="2">
<li><strong>加载方式</strong></li>
</ol>
<p><code>BeanFactroy</code>：采用的是延迟加载形式来注入Bean，也就是只有在使用到某个bean时，才会对该bean进行加载实例化，这样的弊端很明显，就是如果spring的配置存在问题，那么只有<code>BeanFactory</code>加载后，使用到这个bean时才可以发现问题。<br><code>ApplicationContext</code>：<code>ApplicationContext</code>采用的是预加载机制， 在容器启动时，一次性创建所有的bean。这种可以避免<code>BeanFactory</code>接口中出现的问题，容器启动时就可以发现Spring配置中存在的错误，但缺点是会占用内存空间，并且当配置的bean较多时，程序启动会变慢。</p>
<ol start="3">
<li><strong>创建方式</strong></li>
</ol>
<p><code>BeanFactory</code>：采用编程的方式创建，如<code>BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;beans.xml&quot;));</code>。<br><code>ApplicationContext</code>：除了类似<code>BeanFactory</code>采用编程的方式创建外，还可以使用声明的方式创建，在web.xml文件中添加如下代码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--指定Spring配置文件的位置，有多个配置文件时，以逗号分隔--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br><span class="hljs-comment">&lt;!--spring将加载spring目录下的applicationContext.xm1文件--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span><br>    classpath:spring/applicationContext.xml<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><span class="hljs-comment">&lt;!--指定以ContextLoaderLi stener方式启动Spring容器--&gt;</span><br>&lt;1istener&gt;<br>  &lt;1istener-class&gt;<br>    org.springframework.web.context.ContextLoaderListener<br>  &lt;/1istener-class&gt;<br>&lt;/1istener&gt;<br></code></pre></td></tr></table></figure>
<h3 id="依赖注入的方式"><a href="#依赖注入的方式" class="headerlink" title="依赖注入的方式"></a>依赖注入的方式</h3><ol>
<li><strong>Set方法注入(Setter Injection)</strong></li>
</ol>
<p>Setter方法注入是容器通过调用无参构造器或无参static工厂方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。<br>Setter方法注入也称为属性注入(Field Injection)。</p>
<ol start="2">
<li><strong>构造器注入(Constructor Injection)</strong></li>
</ol>
<p>构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p>
<ol start="3">
<li><strong>注解方式</strong></li>
</ol>
<p><code>@Autowired</code>默认按类型装配<br><code>@Resource</code>默认按名称装配，当找不到与名称匹配的bean时，才会按类型装配。</p>
<h3 id="如何选择合适的注入方式"><a href="#如何选择合适的注入方式" class="headerlink" title="如何选择合适的注入方式"></a>如何选择合适的注入方式</h3><p>在实际应用中，没有最好的依赖注入方式，只有最合适的依赖注入方式。<br><strong>选择构造函数注入的理由：</strong></p>
<ul>
<li>不需要为每个属性提供Setter方法，减少了类的方法个数</li>
<li>构造函数可以保证一些重要的属性在Bean实例化时就设置好，避免因为一些重要属性没有提供而导致一个无用Bean实例的情况</li>
<li>可以更好地封装变量，不需要为每个属性指定Setter的方法，避免外部错误调用</li>
</ul>
<p><strong>选择属性注入的理由：</strong></p>
<ul>
<li><p>如果类的属性很多，构造函数将会变得非常臃肿，可读性较差</p>
</li>
<li><p>构造函数注入不够灵活，如果有些属性是可选的，也需要为可选参数提供null值</p>
</li>
<li><p>存在多个构造函数，需要配置文件和构造函数配置歧义问题，配置比较复杂</p>
</li>
<li><p>构造函数不利于类的集成和扩展，因为子类需要引用父类复杂的构造函数</p>
</li>
<li><p>构造函数注入可能产生<strong>循环依赖问题</strong></p>
<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="什么是Spring-AOP"><a href="#什么是Spring-AOP" class="headerlink" title="什么是Spring AOP"></a>什么是Spring AOP</h3><p>AOP是Aspect Oriented Programing的简称，中文为面向切面编程。</p>
<h3 id="AOP解决了什么问题"><a href="#AOP解决了什么问题" class="headerlink" title="AOP解决了什么问题"></a>AOP解决了什么问题</h3><p>在编写代码过程中，经常出现重复的代码，一般情况下会将重复的代码抽象成方法，在需要的地方来调用这个方法，这样就可以减少大量的重复代码。但还是会存在一些问题，比如很多地方都调用了这个方法，突然因业务需求又要删掉，但这个方法已经和业务代码混在了一起， 修改所有调用这个方法的地方也是一个不小的工作量，这种情况就可以用AOP来解决，比如下图中操作数据库的场景：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1657532366196-b520333e-bb31-423e-9b2b-95182d306caf.png#clientId=uc8c1e3f3-896e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=849&id=u3a555976&margin=%5Bobject%20Object%5D&name=image.png&originHeight=849&originWidth=984&originalType=binary&ratio=1&rotation=0&showTitle=false&size=237682&status=done&style=none&taskId=u111f3c45-8e7f-4a69-a4c6-8c4a5220842&title=&width=984" srcset="/img/loading.gif" lazyload alt="image.png"><br>从图片中可以看出，除了执行SQL这部分业务代码，其他都是重复性质的非核心业务代码，AOP的作用就是将这部分非核心代码与核心业务代码分离。<br>Spring AOP是通过<strong>动态代理</strong>来实现的。</p>
<h3 id="AOP的一些名词"><a href="#AOP的一些名词" class="headerlink" title="AOP的一些名词"></a>AOP的一些名词</h3></li>
<li><p>连接点(Joinpoint)：连接点可以理解为程序执行的某个特定位置（如：某个方法调用前、调用后，方法抛出异常后）。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。Spring仅支持方法的连接点。</p>
</li>
<li><p>切点(Pointcut)：如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。</p>
<h3 id="Spring-AOP与AspectJ-AOP有什么区别"><a href="#Spring-AOP与AspectJ-AOP有什么区别" class="headerlink" title="Spring AOP与AspectJ AOP有什么区别"></a>Spring AOP与AspectJ AOP有什么区别</h3><table>
<thead>
<tr>
<th><strong>Spring AOP</strong></th>
<th><strong>AspectJ AOP</strong></th>
</tr>
</thead>
<tbody><tr>
<td>属于运行时增强</td>
<td>属于编译时增强</td>
</tr>
<tr>
<td>基于代理</td>
<td>基于字节码</td>
</tr>
<tr>
<td>仅支持方法级织入</td>
<td>支持字段、方法、构造函数等织入</td>
</tr>
<tr>
<td>比AspectJ慢</td>
<td>比Spring AOP快</td>
</tr>
<tr>
<td>简单</td>
<td>复杂</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="JDK动态代理和CGLIB动态代理的区别"><a href="#JDK动态代理和CGLIB动态代理的区别" class="headerlink" title="JDK动态代理和CGLIB动态代理的区别"></a>JDK动态代理和CGLIB动态代理的区别</h3><p>JDK动态代理和CGLIB动态代理是Spring AOP中用到两种动态代理方式，如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP ，如果目标对象没有实现接口，则会采用CGLIB动态代理，它们的区别如下：</p>
<ul>
<li><p>JDK动态代理是通过反射机制生成一个实现代理接口的匿名类， 在调用具体方法前调InvokeHandler来处理。而CGLIB动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</p>
</li>
<li><p>JDK动态代理的核心是实现InvocationHandler接口，使用invoke()方法进行面向切面的处理，调用相应的通知。CGLIB动态代理核心是实现MethodInterceptor接口， 使用intercept()方 法进行面向切面的处理，调用相应的通知。</p>
</li>
<li><p>JDK动态代理只能代理实现实现接口的类，不能代理没有实现接口的类。CGLIB动态代理是针对类来实现代理的，对指定的目标类生成一个子类，并覆盖其中方法实现增强，不能对final修饰的类进行代理。</p>
</li>
<li><p>在JDK1.6之前，CGLIB动态代理的效率比JDK动态代理要高，JDK1.6开始对JDK动态代理优化后，JDK动态代理的效率比CGLIB动态代理要高，但当大量调用的时候，JDK1.6和JDK 1.7的效率比CGLIB动态代理效率低一些，到JDK1.8，JDK动态代理的效率比CGLIB动态代理高。</p>
<h2 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h2><h3 id="什么是Spring-Bean"><a href="#什么是Spring-Bean" class="headerlink" title="什么是Spring Bean"></a>什么是Spring Bean</h3><p>Spring Bean是Spring框架在运行时管理的对象，如在XML文件中配置的bean。</p>
<h3 id="将一个类声明为Spring-Bean的注解有哪些"><a href="#将一个类声明为Spring-Bean的注解有哪些" class="headerlink" title="将一个类声明为Spring Bean的注解有哪些"></a>将一个类声明为Spring Bean的注解有哪些</h3></li>
<li><p><code>@Component</code>：通用的注解，可标注任意类为Spring组件。如果一个Bean不知道属于哪个层，通常使用此注解。</p>
</li>
<li><p><code>@Controller</code>：Spring MVC控制层组件注解。</p>
</li>
<li><p><code>@Service</code>：服务层组件注解。</p>
</li>
<li><p><code>@Repository</code>：DAO（持久层）组件注解。</p>
<h3 id="Spring中Bean的作用域-Scope-有哪些"><a href="#Spring中Bean的作用域-Scope-有哪些" class="headerlink" title="Spring中Bean的作用域(Scope)有哪些"></a>Spring中Bean的作用域(Scope)有哪些</h3></li>
<li><p><strong>singleton</strong>：Spring中的Bean默认都是单例的，也即每个Bean在每个Spring IoC容器中只有一个实例。</p>
</li>
<li><p><strong>prototype</strong>：每次请求都会创建一个新的bean实例。</p>
</li>
<li><p><strong>request</strong>：每次http请求都会创建一个bean，该作用域仅在基于Web的Spring ApplicationContext情形下有效。</p>
</li>
<li><p><strong>session</strong>：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于Web的Spring ApplicationContext情形下有效。</p>
</li>
<li><p><strong>global-session</strong>：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于Web的Spring ApplicationContext情形下有效。</p>
<h3 id="Spring中Bean的生命周期"><a href="#Spring中Bean的生命周期" class="headerlink" title="Spring中Bean的生命周期"></a>Spring中Bean的生命周期</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904065457979405">如何记忆 Spring Bean 的生命周期</a></p>
<h3 id="Spring怎么解决循环依赖问题"><a href="#Spring怎么解决循环依赖问题" class="headerlink" title="Spring怎么解决循环依赖问题"></a>Spring怎么解决循环依赖问题</h3><h4 id="什么是循环依赖问题"><a href="#什么是循环依赖问题" class="headerlink" title="什么是循环依赖问题"></a>什么是循环依赖问题</h4><p>循环依赖是指A依赖于B，B也依赖于A。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">// A中注入B</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> B b;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-comment">// B中注入A</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> A a;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4></li>
</ul>
<h2 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h2><h3 id="Spring-Bean相关注解"><a href="#Spring-Bean相关注解" class="headerlink" title="Spring Bean相关注解"></a>Spring Bean相关注解</h3><h4 id="Qualifier注解有什么作用"><a href="#Qualifier注解有什么作用" class="headerlink" title="@Qualifier注解有什么作用"></a>@Qualifier注解有什么作用</h4><p><code>@Qualifier</code>注解一般与<code>@Autowired</code>注解一起使用，作用是当存在多个相同类型的bean时，防止<code>@Autowired</code>注解默认按照byType注入时的混乱问题。在<code>@Qualifier</code>中写上bean的名称即可。</p>
<h3 id="Web开发相关注解"><a href="#Web开发相关注解" class="headerlink" title="Web开发相关注解"></a>Web开发相关注解</h3><h4 id="Controller注解有什么用"><a href="#Controller注解有什么用" class="headerlink" title="@Controller注解有什么用"></a>@Controller注解有什么用</h4><p><code>@Controller</code>，对应Spring MVC控制层，主要用户接受用户请求并调用Service层返回数据给前端页<br>面。</p>
<h4 id="ResponseBody注解有什么用"><a href="#ResponseBody注解有什么用" class="headerlink" title="@ResponseBody注解有什么用"></a>@ResponseBody注解有什么用</h4><p><code>@ResponseBody</code>通常和<code>@Controller</code>一起使用，<code>@ResponseBody</code>注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区(响应体中) ,通常用来返回SON数据或者是XML。</p>
<h3 id="Spring-AOP相关注解"><a href="#Spring-AOP相关注解" class="headerlink" title="Spring AOP相关注解"></a>Spring AOP相关注解</h3><blockquote>
<p>AOP的注解主要有@Aspect、@Pointcut、@Around、@Before、@After、@AfterReturning、@AfterThrowing。</p>
</blockquote>
<ul>
<li><code>@Aspect</code>，声明一个切面</li>
<li><code>@Pointcut</code>，增强的切入点</li>
<li><code>@Before</code>，前置注解，被注解的方法将会在目标方法之前执行</li>
<li><code>@After</code>，最终注解，被注解的方法将在执行完所有的注解方法后再执行(始终执行)</li>
<li><code>@Around</code>，环绕注解，被注解的方法将会之前和之后都进行执行</li>
<li><code>@AfterReturning</code>，后置注解，被注解的方法将会在目标方法执行之后执行(异常不执行)</li>
<li><code>@AfterThrowing</code>，出现异常后执行<h2 id="Spring事务相关"><a href="#Spring事务相关" class="headerlink" title="Spring事务相关"></a>Spring事务相关</h2><h3 id="Spring事务的传播行为"><a href="#Spring事务的传播行为" class="headerlink" title="Spring事务的传播行为"></a>Spring事务的传播行为</h3>事务的传播行为主要是解决多个方法之间相互调用所产生的事务问题，是Spring框架所提供的事务工具所独有的。<br>用伪代码说明如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方法methodA调用开启事务并设置事务传播行为的methodB，即是事务传播行为问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>    methodB();<br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-meta">@Traction(Propagation = XXX)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>Spring中七种事务传播行为</p>
<table>
<thead>
<tr>
<th><strong>事务传播行为</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_REQUIRED</td>
<td>如果当前没有事务，就新建一个事务；如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>使用当前的事务，如果当前没有事务，就抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>新建事务，如果当前存在事务，把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>以非事务方式执行，如果当前存在事务，则抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td>
</tr>
</tbody></table>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="什么是Spring-MVC"><a href="#什么是Spring-MVC" class="headerlink" title="什么是Spring MVC"></a>什么是Spring MVC</h3><p>Spring MVC是Spring框架中的一个组件，是其提供的一个基于MVC设计模式的轻量级Web开发框架，本质上相当于Servlet。<br>MVC设计模式，Model View Controller；Model是一个存取数据的对象，View表示模型包含数据的可视化，Controller用于控制数据流向模型对象，并在数据变化时更新视图。</p>
<h3 id="Spring-MVC的优点"><a href="#Spring-MVC的优点" class="headerlink" title="Spring MVC的优点"></a>Spring MVC的优点</h3><p>它将model、view、controller分离，对web层进行解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。<br>对业务系统各个组件解耦，提高系统的可维护性和扩展性。</p>
<h3 id="Spring-MVC的工作原理"><a href="#Spring-MVC的工作原理" class="headerlink" title="Spring MVC的工作原理"></a>Spring MVC的工作原理</h3><p>Spring MVC的工作流程图如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/26705318/1658299153930-09bd88a8-81f4-40f9-b922-aa4b82669894.png#clientId=u146ac9cd-79d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=563&id=uffdfa075&margin=%5Bobject%20Object%5D&name=image.png&originHeight=563&originWidth=1164&originalType=binary&ratio=1&rotation=0&showTitle=false&size=260108&status=done&style=none&taskId=u3eba2e6a-e93d-4e18-8e58-21585ea2af5&title=&width=1164" srcset="/img/loading.gif" lazyload alt="image.png"><br>流程说明如下：<br>(1) 客户端发出一个http请求，web应用服务器接收到这个请求，如果匹配到DispatcherServlet的请求映射路径，web容器会将这个http请求交给DispatcherServlet处理；<br>(2) - (3) DispatcherServlet接收到请求后，根据请求的信息与HandlerMapping的配置找到处理请求的Handler；<br>(4) - (5) DispatcherServlet找到Handler后，通过HandlerAdapter对Handler进行封装，然后再调用Handler；<br>(6) - (7) Handler处理业务逻辑，并返回ModelAndView到DispatcherServlet，ModelAndView包含了视图逻辑名和模型数据信息；<br>(8) - (9) ModelAndView包含的并非真正的视图对象，DispatcherServlet借助ViewResolver完成逻辑视图名到真实视图对象的解析工作；<br>(10) - (11) DispatcherServlet通过真实视图对象View对ModelAndView中的模型数据进行视图渲染；<br>(12) 将渲染的结果返回给客户端。</p>
<h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><h3 id="Spring-Boot的特点"><a href="#Spring-Boot的特点" class="headerlink" title="Spring Boot的特点"></a>Spring Boot的特点</h3><ul>
<li>内嵌tomcat和jetty容器，不需要部署war文件到Web容器就可以独立运行应用</li>
<li>提供许多基于Maven的pom配置模板来简化工程配置</li>
<li>可以实现自动化配置</li>
<li>开箱即用，不需要xmI等配置文件<h3 id="Spring-Boot自动配置原理"><a href="#Spring-Boot自动配置原理" class="headerlink" title="Spring Boot自动配置原理"></a>Spring Boot自动配置原理</h3>简单来说就是<code>@SpringBootApplication</code>注解会对jar包下的<strong>spring.factories</strong>文件进行扫描，这个文件中包含了可以进行自动配置的类，当满足<code>@Condition</code>注解指定的条件时，便在依赖的支持下进行实例化，注册到Spring容器中。</li>
</ul>
<hr>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h2><h3 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h3><p>Redis是一个高性能的非关系型的键值对数据库。<br>与传统的数据库不同的是Redis存在内存中，所以读写速度非常快，这也是Redis被用作缓存的原因。</p>
<h3 id="Redis的优缺点"><a href="#Redis的优缺点" class="headerlink" title="Redis的优缺点"></a>Redis的优缺点</h3><p><a target="_blank" rel="noopener" href="https://www.yuque.com/poetr/pcno4b/nwyqtq">Redis</a></p>
<h3 id="Redis为什么用作缓存？相比于Guava有什么优势？"><a href="#Redis为什么用作缓存？相比于Guava有什么优势？" class="headerlink" title="Redis为什么用作缓存？相比于Guava有什么优势？"></a>Redis为什么用作缓存？相比于Guava有什么优势？</h3><p>缓存的定义是访问速度比一般随机存取存储器快的一种高速存储器，而因为Redis是基于内存提供了高性能的数据存取功能，其比较显著的优势就是非常地快。<br>缓存可以分为本地缓存或者分布式缓存，比较常用的guava缓存就是一种本地缓存，其主要特点是轻量并且快速，生命周期随着JVM的销毁而结束，缺点是在多实例的情况下，每个实例都要自己保存一份缓存，这样会导致缓存的一致性出现问题。<br>Redis则是分布式缓存，在多实例情况下，每个实例都共享一份缓存数据， 缓存具备一致性。 缺点是要保持Redis的高可用整体架构会比较复杂。</p>
<h3 id="Redis-6-0之后为什么引入了多线程"><a href="#Redis-6-0之后为什么引入了多线程" class="headerlink" title="Redis 6.0之后为什么引入了多线程"></a>Redis 6.0之后为什么引入了多线程</h3><p>前面也说了Redis的瓶颈在内存和网络，Redis6.0引入多线程主要是为了解决网路IO读写这个瓶颈，执行命令还是单线程执行的，所以也不存在线程安全问题。<br>Redis6.0默认是否开启了多线程呢?<br>默认是没有开启的，如需开启，需要修改配置文件redis.conf: io-threads-do-reads no，no改为yes。</p>
<h3 id="Redis的数据类型有哪些"><a href="#Redis的数据类型有哪些" class="headerlink" title="Redis的数据类型有哪些"></a>Redis的数据类型有哪些</h3><p>Redis常见的数据类型有<strong>五种</strong>，即<strong>String、Hash、Set、List和ZSet。</strong></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>可以存储的值</th>
<th>操作</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作；</td>
<td></td>
</tr>
<tr>
<td>对整数和浮点数执行自增或者自减操作。</td>
<td>键值对缓存及常规计数；</td>
<td></td>
<td></td>
</tr>
<tr>
<td>微博数、粉丝数</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>List</td>
<td>列表（内部使用双向链表实现）</td>
<td>从两端压入或者弹出元素；</td>
<td></td>
</tr>
<tr>
<td>对单个或者多个元素进行修剪，只保留一个范围内的元素。</td>
<td>存储文章ID列表、存储评论列表等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Set</td>
<td>无序集合（内部使用值为空的散列表）</td>
<td>添加、获取、移除单个元素；</td>
<td></td>
</tr>
<tr>
<td>检查一个元素是否存在于集合中；</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>计算交集、并集、差集；</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>从集合里面随机获取元素。</td>
<td>共同好友、共同关注等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ZSet</td>
<td>有序集合（内部使用散列表和跳表）</td>
<td>添加、获取、删除元素；</td>
<td></td>
</tr>
<tr>
<td>根据分值范围或者成员来获取元素；</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>计算一个键的排名。</td>
<td>去重、获取排名前几的用户</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Hash</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对；</td>
<td></td>
</tr>
<tr>
<td>获取所有键值对；</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>检查某个键是否存在。</td>
<td>常用于存储对象</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="Redis的数据结构有哪些"><a href="#Redis的数据结构有哪些" class="headerlink" title="Redis的数据结构有哪些"></a>Redis的数据结构有哪些</h3><p>Redis的数据结构有<strong>简单动态字符串（SDS）、链表、字典、跳跃表、整数集合、压缩列表等。</strong></p>
<ul>
<li><strong>链表</strong>：链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。链表是列表的底层实现之一。</li>
<li><strong>字典</strong>：又称为符号表(symbol table)、关联数组(associativearray) 或映射(map) ，是一种用于保存键值对(key-value pair)的抽象数据结构。字典在Redis中的应用相当广泛，比如Redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。</li>
<li><strong>整数集合</strong>：整数集合(intset) 是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。|</li>
<li>**压缩列表(ziplist)**：压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型(sequential) 数据结构。</li>
<li><strong>跳跃表（skiplist）</strong>：跳跃表是一种有序数据结构，它通过在每个节点维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表支持平均O(logN)，最坏O(N)时间复杂度的节点查找，还可以通过顺序性操作来批量处理节点。跳跃表是有序集合键的底层实现之一。</li>
</ul>
<p>跳跃表本质上采用的是一种<strong>空间换时间的策略</strong>， 是一种可以可以进行二分查找的有序链表，跳表在原有的有序链表上增加了多级索引，通过索引来实现快速查询。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。</p>
<h3 id="Redis的应用场景有哪些"><a href="#Redis的应用场景有哪些" class="headerlink" title="Redis的应用场景有哪些"></a>Redis的应用场景有哪些</h3><ul>
<li>缓存：Redis基于内存，读写速度非常快，并且有键过期功能和键淘汰策略，可以作为缓存使用。</li>
<li>排行榜：Redis提供的有序集合可以很方便地实现排行榜。</li>
<li>分布式锁：Redis的setnx功能来实现分布式的锁。</li>
<li>社交功能：实现共同好友、共同关注等。</li>
<li>计数器：通过String进行自增自减实现计数功能。</li>
<li>消息队列：Redis提供了发布、订阅、阻塞队列等功能，可以实现一个简单的消息队列。</li>
</ul>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="MyBatis与Hibernate比较"><a href="#MyBatis与Hibernate比较" class="headerlink" title="MyBatis与Hibernate比较"></a>MyBatis与Hibernate比较</h2><p><strong>相同点</strong></p>
<ul>
<li>MyBatis和Hibernate都是ORM（对象关系映射）框架，是对JDBC的封装；</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li><p>从ORM：MyBatis是半ORM，Hibernate是完全ORM；MyBatis是一个半自动映射的框架，配置Java对象与sq|语句执行结果的对应关系，多表关联关系配置简单；Hibernate是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂。</p>
</li>
<li><p>MyBatis相比Hibernate更加轻量，启动速度更快</p>
</li>
<li><p>从SQL优化和移植性：Hibernate对SQL语句封装，提供了日志、缓存、级联(级联比MyBatis强大)等特性，此外还提供HQL(Hibernate Query Language)操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。MyBatis需要手动编写SQL，支持动态SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sq|语句优化容易。</p>
</li>
<li><p>从开发难度和学习成本：Hibernate是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如办公自动化系统；MyBatis是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如互联网电子商务系统。</p>
</li>
<li><p>总结：MyBatis是一个小巧、方便、高效、简单、直接、半自动的持久层框架；Hibernate是一个强大、方便、高效、复杂、间接、全自动的持久层框架。</p>
<h2 id="为什么说MyBatis是半自动ORM映射工具"><a href="#为什么说MyBatis是半自动ORM映射工具" class="headerlink" title="为什么说MyBatis是半自动ORM映射工具"></a>为什么说MyBatis是半自动ORM映射工具</h2><p>Hibernate属于全⾃动ORM映射⼯具，使⽤Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而MyBatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射⼯具。</p>
<h2 id="MyBatis框架适用场景"><a href="#MyBatis框架适用场景" class="headerlink" title="MyBatis框架适用场景"></a>MyBatis框架适用场景</h2></li>
<li><p>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案；</p>
</li>
<li><p>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。</p>
<h2 id="MyBatis都有哪些Executor执行器"><a href="#MyBatis都有哪些Executor执行器" class="headerlink" title="MyBatis都有哪些Executor执行器"></a>MyBatis都有哪些Executor执行器</h2><p>Mybatis有三种基本的Executor执⾏器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p>
<h2 id="MyBatis是否支持延迟加载"><a href="#MyBatis是否支持延迟加载" class="headerlink" title="MyBatis是否支持延迟加载"></a>MyBatis是否支持延迟加载</h2><p>MyBatis仅⽀持association关联对象和collection关联集合对象的延迟加载，association指的就是⼀对⼀，collection指的就是⼀对多查询。在MyBatis配置⽂件中，可以配置是否启⽤延迟加载<code>lazyLoadingEnabled=true|false</code>。<br>它的原理是，使⽤CGLIB创建⽬标对象的代理对象，当调⽤⽬标⽅法时，进⼊拦截器⽅法，比如调⽤<code>a.getB().getName()</code>，拦截器invoke()⽅法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调⽤a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()⽅法的调⽤。这就是延迟加载的基本原理。</p>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95/" class="category-chain-item">面试</a>
  
  
    <span>></span>
    
  <a href="/categories/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/" class="category-chain-item">面试题库</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%8E%9F%E5%88%9B/">#原创</a>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">#数据库</a>
      
        <a href="/tags/MySQL/">#MySQL</a>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95/">#面试</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试题库</div>
      <div>https://miderl.github.io/2022/08/02/面试题库/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>MiderL</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年8月2日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/08/10/SQL%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/" title="SQL优化技巧">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">SQL优化技巧</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" title="数据库分库分表">
                        <span class="hidden-mobile">数据库分库分表</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"OkhbwGMKq8QHprfkicG7YrD1-gzGzoHsz","appKey":"YKOtvJConydfNHSzzY08cEao","path":"window.location.pathname","placeholder":"说点什么","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
